<!DOCTYPE HTML>
<html>
<head>
  <title>Visor de Modelos 3D</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    .container { display: flex; height: 100vh; width: 100vw; }
    .left-panel { flex: 1 1 60%; display: flex; align-items: stretch; justify-content: stretch; background: #222; }
    .right-panel {
      flex: 0 0 340px;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      padding: 32px 24px;
      box-shadow: -2px 0 16px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      min-width: 300px;
      max-width: 400px;
      height: 100vh;
      box-sizing: border-box;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
    }
    #webglcanvas { 
      border: none; 
      background: #000; 
      box-shadow: 0 0 12px #0008; 
      width: 100%; 
      height: 100%; 
      max-width: 100%; 
      max-height: 100%; 
      display: block; 
    }
    .right-panel h2 {
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 1.5em;
      letter-spacing: 1px;
      color: #ffb347;
      text-shadow: 1px 1px 4px #0008;
      text-align: center;
    }
    .menu-group {
      margin-bottom: 7px;
      padding: 5px 0 0 0;
      border-bottom: 1px solid #4446;
    }
    .menu-group:last-child {
      border-bottom: none;
    }
    .menu-group label {
      font-size: 1.08em;
      margin-right: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #ffe082;
      font-weight: 500;
    }
    .menu-group input[type="checkbox"] {
      accent-color: #ffb347;
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .menu-group select, .menu-group input[type="file"] {
      margin-top: 6px;
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid #ffb347;
      background: #232526;
      color: #fff;
      font-size: 1em;
      outline: none;
      transition: border 0.2s;
    }
    .menu-group select:focus, .menu-group input[type="file"]:focus {
      border: 1.5px solid #ffe082;
    }
    .right-panel button {
      padding: 7px 22px;
      font-size: 1.08em;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg, #ffb347 0%, #ffcc80 100%);
      color: #232526;
      font-weight: bold;
      cursor: pointer;
      margin-top: 7px;
      margin-bottom: 7px;
      box-shadow: 0 2px 8px #0002;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }
    .right-panel button:hover {
      background: linear-gradient(90deg, #ffe082 0%, #ffb347 100%);
      color: #222;
      transform: scale(1.04);
    }
    .menu-info {
      font-size: 1em;
      color: #ffe082;
      margin-top: 28px;
      background: #232526cc;
      border-radius: 8px;
      padding: 5px 12px;
      box-shadow: 0 1px 6px #0003;
      text-align: center;
      letter-spacing: 0.5px;
    }
    /* Extra: animación de entrada */
    .right-panel {
      animation: fadeInMenu 1s;
    }
    @keyframes fadeInMenu {
      from { opacity: 0; transform: translateX(40px);}
      to   { opacity: 1; transform: translateX(0);}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="left-panel">
      <canvas id="webglcanvas" oncontextmenu="return false;"></canvas>
    </div>
    <div class="right-panel">
      <div class="menu-group">
        <label>
          <input type="checkbox" id="autoRotateY">
          Rotación automática Y
        </label>
      </div>
      <div class="menu-group">
        <label>
          <input type="checkbox" id="autoRotateX">
          Rotación automática X
        </label>
      </div>
      <div class="menu-group">
        <label>
          <input type="checkbox" id="arcballControl" checked>
          Control ArcBall manual
        </label>
      </div>
      <div class="menu-group">
        <label>
          <input type="checkbox" id="moveModel">
          Mover el modelo (botón derecho)
        </label>
      </div>
      <div class="menu-group">
        <label>
          <input type="checkbox" id="showAxes">
          Mostrar/Ocultar ejes XYZ
        </label>
      </div>
      <div class="menu-group">
        <button id="reset">Resetear vista</button>
      </div>
      <div class="menu-group">
        <label>Escalar:</label>
        <button id="scaleUp">Agrandar</button>
        <button id="scaleDown">Reducir</button>
      </div>
      <div class="menu-group">
        <label for="objeto3d">Objeto:</label>
        <select id="objeto3d">
          <option value="cubo">Cubo</option>
          <option value="cilindro">Cilindro</option>
          <option value="cono">Cono</option>
          <option value="obj">OBJ</option>
        </select>
        <input type="file" id="objFile" accept=".obj" style="display:none; margin-top:8px;">
      </div>
      <div class="menu-info">
        <b>Zoom:</b> Usa la rueda del mouse<br>
        <b>Rotar:</b> Botón izquierdo<br>
        <b>Trasladar:</b> Botón derecho<br>
        <b>ArcBall:</b> Activa/desactiva con el checkbox<br>
      </div>
    </div>
  </div>

  <!--
    /***************************************************************************/
    /* Se definen los códigos shaders.                                         */
    /***************************************************************************/
  -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    out vec4 vColores;
    void main() {
      vColores = aColores;  
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    out vec4 color;
    void main() {
        color = vColores;
    }
  </script>

  <script>
    "use strict";

    /* Variables globales */
    var canvas;
    var programaID;
    var gl;
    var cubo;
    var arcBall;
    var autoRotate = false;    // Rotación automática en Y
    var autoRotateX = false;   // Rotación automática en X
    var autoRotateY = false;   // Rotación automática en Y
    var arcballControl = true; // Controla si el ArcBall está activo
    var moveModel = false; // Controla si la traslación con botón derecho está activa
    var showAxes = false; // Mostrar/Ocultar ejes XYZ
    var wireframe = false; // Mostrar como malla
    var objetoActual = "cubo";
    var cilindro, cono;
    var objetoOBJ = null;

    /* Variables Uniformes */
    var uMatrizProyeccion;
    var uMatrizVista;
    var uMatrizModelo;

    /* Matrices */
    var MatrizProyeccion = new Array(16);
    var MatrizVista = new Array(16);
    var MatrizModelo = new Array(16);

    /* Para la interacción */
    var tx = 0, ty = 0;
    var sx = 1, sy = 1, sz = 1;
    var MatrizRotacion = new Array(16);
    var Matriz = new Array(16);
    var boton_izq_presionado = false;
    var boton_der_presionado = false;

    /***************************************************************************/
    /* Se crean, compilan y enlazan los programas Shader                       */
    /***************************************************************************/
    function compilaEnlazaLosShaders() {

      /* Se compila el shader de vertice */
      var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeVertice));
      }

      /* Se compila el shader de fragmento */
      var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
         console.error(gl.getShaderInfoLog(shaderDeFragmento));
      }

      /* Se enlaza ambos shader */
      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice); 
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
         console.error(gl.getProgramInfoLog(programaID));
      }

      /* Se instala el programa de shaders para utilizarlo */
      gl.useProgram(programaID);
    }

    /***************************************************************************/
    /* Transformaciones mediante matrices                                      */
    /***************************************************************************/

    /* Convierte de grados a radianes */
    function toRadians(grados) {
      return grados * Math.PI / 180;
    };

    /* Matriz Identidad */
    function identidad(r) {
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /* Traslación - glTranslatef */
    function traslacion(matriz, tx, ty, tz) {
      var r = new Array(16);
      r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    /* Escalación - glScalef */
    function escalacion(matriz, sx, sy, sz) { 
      var r = new Array(16);
      r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
      r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
      r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre X - glRotatef */
    function rotacionX(matriz, theta){
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
      r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
      r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r); 
    }

    /* Rotación sobre Y - glRotatef */
    function rotacionY(matriz, theta){
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
      r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
      r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre Z - glRotatef */
    function rotacionZ(matriz, theta){
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
      r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
      r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
      r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Proyección Paralela - glOrtho */
    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
      r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
      r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
      r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
    }

    /* Proyección Perspectiva - glFrustum */
    function frustum(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2*cerca/(der-izq); r[4] =                 0; r[ 8] =          (der+izq)/(der-izq); r[12] =                            0;
      r[1] =                 0; r[5] = 2*cerca/(arr-abj); r[ 9] =          (arr+abj)/(arr-abj); r[13] =                            0;
      r[2] =                 0; r[6] =                 0; r[10] = -(lejos+cerca)/(lejos-cerca); r[14] = -2*lejos*cerca/(lejos-cerca);
      r[3] =                 0; r[7] =                 0; r[11] =                           -1; r[15] =                            0;
    }

    /* Proyección Perspectiva - gluPerspective */
    function perspective(r, fovy, aspecto, cerca, lejos) {
      var ang = fovy * 0.5;
      var f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
      r[0] = f/aspecto; r[4] = 0; r[ 8] =                                  0; r[12] =                                       0;
      r[1] =         0; r[5] = f; r[ 9] =                                  0; r[13] =                                       0;
      r[2] =         0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] =  -2.0 * lejos * cerca / (lejos - cerca);
      r[3] =         0; r[7] = 0; r[11] =                              - 1.0; r[15] =                                       0;
    }

    /* Multiplicación de matrices de 4 x 4 */
    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++){
        for (j = 0; j < 4; j++){
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    /***************************************************************************/
    /* La Clase Vector3                                                        */
    /***************************************************************************/

    class Vector3 {

      /**
       * Construye un nuevo Vector.
       */
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }

      /**
       *                   u = Suma de vectores
       *  u = v1 + v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                   u = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
       */
      mas(v2) {
        return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
      }

      /**
       *                   u = Resta de vectores
       *  u = v1 - v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                   u = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
       */
      menos(v2) {
        return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
      }

      /**
       *                      u x v = Producto vectorial o producto cruz
       * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       * v = (v.x, v.y, v.z)  u x v = (u.y * v.z - u.z * v.y,   
       *                               u.z * v.x - u.x * v.z,
       *                               u.x * v.y - u.y * v.x)                  
       */
      producto_vectorial(v2) {
        var r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y);
        r.y = (this.z * v2.x) - (this.x * v2.z);
        r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }

      /**
       *                      u . v = Producto escalar o producto punto
       * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       * v = (v.x, v.y, v.z)  u . v = u.x v.x + u.y v.y + u.z v.z
       *                                          
       */
      producto_escalar(v2) {
        return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
      }

      /**
       *                     |v| = Longitud de un vector o magnitud
       * v = (x, y, z)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                     |v| = raiz_cuadrada (x^2 + y^2 + z^2) 
       *                                          
       */
      longitud() {
        return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
      }

      /**
       *        v            u = Vector unitario o de longitud 1
       *  u  = ---        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *       |v|           u = Vector normalizado
       *                     
       */
      normaliza() {
        var l = this.longitud();
        if (l > 0 ) {
          this.x = this.x / l;
          this.y = this.y / l;
          this.z = this.z / l;
        }
      }
      /**
       *    3
       *     ^
       *     |
       *   v |
       *     |
       *    1 -------- > 2
       */
      normal(v1, v2, v3) {
        var u = new Vector3(); // vector u
        var v = new Vector3(); // vector v
        var n = new Vector3(); // vector n

        /* Calcula los vectores u y v */
        u = v2.menos(v1);
        v = v3.menos(v1);

        /* n = u x v */
        n = u.producto_vectorial(v);
    
        /* Normaliza */
        n.normaliza();
    
        return n;
      }

      toString() {
        return "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***************************************************************************/
    /* ArcBall: Obtiene los vectores U y V de la esfera (x^2 + y^2 + z^2 = 1). */
    /***************************************************************************/

    var Punto2f = function(x, y) {
      // Atributos publicos
      this.x = x;
      this.y = y;
    }

    class ArcBall {

      /**
       * Construye un nuevo ArcBall.
       */
      constructor(w, h) {
        this.Epsilon = 1.0e-5;
        this.U = new Vector3();
        this.V = new Vector3();
        this.ajusta(w, h);
      }

      /* Ajusta el ancho y alto de la ventana */
      ajusta(w, h) {
        if (!((w > 1.0) && (h > 1.0)))
          document.write("ERROR");

        /* Ajusta el factor para el ancho y alto (2 = [-1..1]) */
        this.ajustaAncho = 2.0 / (w - 1.0);
        this.ajustaAlto = 2.0 / (h - 1.0);
      }

      /* Obtiene el vector dado un punto (x,y) */
      obtieneVector(vector, x, y) {
        /* Copia punto */
        let temp = new Punto2f(x, y);

        /* Ajusta las coordenadas del punto al rango [-1..1] */
        temp.x = (temp.x * this.ajustaAncho) - 1.0;
        temp.y = 1.0 - (temp.y * this.ajustaAlto);

        /* Calcula el cuadrado de la longitud del vector */
        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);
    
        /* 
         * Considerando que: radio^2 = x^2 + y^2 + z^2
         * ¿Cuales son los valores de x, y y z?
         * 
         * Si el punto está fuera de la esfera... (longitud2 > 1)
         */

        if (longitud2 > 1.0) {
          /* Calcula un factor de normalización (radio / sqrt(longitud2)) */
          let norma = (1.0 / Math.sqrt(longitud2));

          /* Retorna el vector "normalizado", un punto sobre la esfera */
          vector.x = temp.x * norma;
          vector.y = temp.y * norma;
          vector.z = 0.0;
        } else { /* e.o.c. está dentro */
          /*
           * Retorna un vector, un punto dentro la esfera 
           * z = sqrt(radio^cuadrado - (x^2 + y^2))
           */
          vector.x = temp.x;
          vector.y = temp.y;
          vector.z = Math.sqrt(1.0 - longitud2);
        }
      }

      /* Obtiene el vector U */
      primerPunto(x, y) {
        this.obtieneVector(this.U, x, y);
      }

      /* Obtiene el Cuaternion de U y V */
      segundoPunto(x, y) {

        let q = new Cuaternion();

        /* Obtiene el vector V */
        this.obtieneVector(this.V, x, y);

        /* Retorna el cuaternión equivalente a la rotación. */
        if (q != null) {

          /* Calcula la Normal = U x V */
          let Normal = this.U.producto_vectorial(this.V);

          /* Calcula la longitud de la normal */
          if (Normal.longitud() > this.Epsilon) { /* si no es cero */
            q.x = Normal.x;
            q.y = Normal.y;
            q.z = Normal.z;
            /* w  = (theta / 2), donde theta es el ángulo de rotación */
            q.w = this.U.producto_escalar(this.V);
          } else { /* si es cero */
            /* U y V coinciden */
            q.x = q.y = q.z = q.w = 0.0;
          }
        }
        return q;
      }
    }

    /***************************************************************************/
    /* Cuaternion: Realiza las operaciones de los cuaterniones.                */
    /***************************************************************************/

    class Cuaternion {

      /**
       * Construye un nuevo Cuaternion.
       */
      constructor(w, x, y, z) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
      }

      inicializa(w, v) {
        this.w = w;
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      }

      // norma^2 = w^2 + x^2 + y^2 + z^2
      norma2() {
        return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
      }

      // Conjugado
      conjugado() {
        x = -this.x;
        y = -this.y;
        z = -this.z;
        return this;
      }

      // Cuaternion q = Cuaternion a . Cuaternion b
      multiplica(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
        q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
        q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
        return q;
      }

      // Cuaternion q = Cuaternion a . b
      multiplica_escalar(a, b) {
        let q = new Cuaternion(0,0,0,0);
        q.w = a.w * b;
        q.x = a.x * b;
        q.y = a.y * b;
        q.z = a.z * b;
        return q;
      }

      // q' = q . p . q^(-1)
      rota(q, p) {   // q es Cuaternion y p es Vector3
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.inverso()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }
  
      // q' = q . p . q*
      rota1(q, p) {  // q es Cuaternion y p es Vector3
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.conjugado()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }

      // q = q^(-1)
      inverso() {
        let q = new Cuaternion(0,0,0,0);
        // normal^2 = a . b
        let n = this.norma2();
        if (n <= 1e-8)
          document.write("INVERSO: Error");
        q = multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
        return q;
      }

      /* Convierte el cuaternión a una matriz de rotación */
      static rota2(a, q) {
        let d, s;
        d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
        s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] =  1.0 - (q.y*q.y + q.z*q.z) * s; a[4] =        (q.x*q.y - q.w*q.z) * s; a[8]  =        (q.x*q.z + q.w*q.y) * s; a[12] = 0;
        a[1] =        (q.x*q.y + q.w*q.z) * s; a[5] = 1.0  - (q.x*q.x + q.z*q.z) * s; a[9]  =        (q.y*q.z - q.w*q.x) * s; a[13] = 0;
        a[2] =        (q.x*q.z - q.w*q.y) * s; a[6] =        (q.y*q.z + q.w*q.x) * s; a[10] = 1.0  - (q.x*q.x + q.y*q.y) * s; a[14] = 0;
        a[3] =                              0; a[7] =                              0; a[11] =                              0; a[15] = 1;
      }

      toString() {
        return "Cuaternion [w=" + this.w + ", x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***********************************************************************************/
    /* Se define la geometría y se almacenan en los buffers de memoria y se renderiza. */
    /***********************************************************************************/
    class Cubo {
      constructor(gl) {

        /**
         *       3 --------- 2
         *       /|        /|   
         *      / |       / |
         *    7 --------- 6 |
         *     |  |      |  |
         *     | 0 ------|-- 1 
         *     | /       | /
         *     |/        |/
         *    4 --------- 5  
         */

        /* Las coordenadas cartesianas (x, y, z) */
        var vertices = [
           // Frente
           -1, -1,  1, // 4   0
            1, -1,  1, // 5   1
            1,  1,  1, // 6   2
           -1,  1,  1, // 7   3
           // Atrás
           -1,  1, -1, // 3   4
            1,  1, -1, // 2   5
            1, -1, -1, // 1   6
           -1, -1, -1, // 0   7
           // Izquierda
           -1, -1, -1, // 0   8
           -1, -1,  1, // 4   9
           -1,  1,  1, // 7  10 
           -1,  1, -1, // 3  11
           // Derecha
            1, -1,  1, // 5  12 
            1, -1, -1, // 1  13
            1,  1, -1, // 2  14
            1,  1,  1, // 6  15
           // Abajo
           -1, -1, -1, // 0  16
            1, -1, -1, // 1  17
            1, -1,  1, // 5  18
           -1, -1,  1, // 4  19
           // Arriba
           -1,  1,  1, // 7  20
            1,  1,  1, // 6  21
            1,  1, -1, // 2  22
           -1,  1, -1  // 3  23
        ];

        /* Los colores x c/vértice (r,g,b,a) */
        var colores = [
           // Frente - lila
            1, 0, 1, 1, // 4   0
            1, 0, 1, 1, // 5   1
            1, 0, 1, 1, // 6   2
            1, 0, 1, 1, // 7   3  
           // Atrás - amarillo
            1, 1, 0, 1, // 3   4  
            1, 1, 0, 1, // 2   5
            1, 1, 0, 1, // 1   6  
            1, 1, 0, 1, // 0   7  
           // Izquierda - celeste
            0, 1, 1, 1, // 0   8
            0, 1, 1, 1, // 4   9
            0, 1, 1, 1, // 7  10
            0, 1, 1, 1, // 3  11
           // Derecha - rojo
            1, 0, 0, 1, // 5  12
            1, 0, 0, 1, // 1  13
            1, 0, 0, 1, // 2  14
            1, 0, 0, 1, // 6  15
           // Abajo - azul
            0, 0, 1, 1, // 0  16
            0, 0, 1, 1, // 1  17
            0, 0, 1, 1, // 5  18
            0, 0, 1, 1, // 4  19
           // Arriba - verde
            0, 1, 0, 1, // 7  20
            0, 1, 0, 1, // 6  21
            0, 1, 0, 1, // 2  22
            0, 1, 0, 1  // 3  23
        ];

        /* Indices */
        var indices = [ 
          0,  1,  2,  0,  2,  3, // Frente
          4,  5,  6,  4,  6,  7, // Atrás
          8,  9, 10,  8, 10, 11, // Izquierda 
         12, 13, 14, 12, 14, 15, // Derecha
         16, 17, 18, 16, 18, 19, // Abajo
         20, 21, 22, 20, 22, 23  // Arriba
        ];

        this.cuboVAO = gl.createVertexArray();
        gl.bindVertexArray(this.cuboVAO);

        var codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

         var codigoDeIndices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.cuboVAO);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class Cilindro {

          /* segmentosH = slices o longitud, segmentosV = stacks o latitud  */
          constructor(gl, radio, alto, cantidadDeSectores, arriba, abajo) {

            var i, j, kv, kc, ki, angulo, x, y;

            var cantidadDeVertices = 4 * cantidadDeSectores + 6;
            var cantidadDeTriangulos = 2 * cantidadDeSectores;
            
            if (arriba) {
              cantidadDeTriangulos += cantidadDeSectores;
            }

            if (abajo) {
              cantidadDeTriangulos += cantidadDeSectores;
            }
            this.cantidadDeIndices = cantidadDeTriangulos * 3;

            /* Las coordenadas cartesianas (x, y, z) */
            var vertices = new Float32Array(cantidadDeVertices * 3);

            /* Los colores x c/vértice (r,g,b,a) */
            var colores = new Float32Array(cantidadDeVertices * 4);

            /* Indices */
            var indices = new Uint16Array(this.cantidadDeIndices); 

            /* Se leen los vertices */
            kv = 0;
            kc = 0;
            var anguloDelSector = 2 * Math.PI / cantidadDeSectores; // 1 vuelta (en radianes)/cantidad de sectores

            // Circulo de arriba y abajo
            for (i = 0; i <= cantidadDeSectores; i++) {
              angulo = i * anguloDelSector;

              x = Math.cos(angulo);
              y = Math.sin(angulo);

              vertices[kv++] = radio * x;
              vertices[kv++] = radio * y;
              vertices[kv++] = -alto/2;

              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 0;
              colores[kc++] = 1;

              vertices[kv++] = radio * x;
              vertices[kv++] = radio * y;
              vertices[kv++] = alto/2;

              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 0;
              colores[kc++] = 1;
            }

            /* Se leen los indices */
     	
            /**
             *    1 ------- 3
             *     |     / | 
             *     |   /   |
             *     | /     |
             *    0 ------- 2
             *    0,2,3, 0,3,1     =>  6 indices
             */
            ki = 0
            for (i = 0, j = 0; j < cantidadDeSectores; i += 2, j++) {
              indices[ki++] = i;
              indices[ki++] = i + 2;
              indices[ki++] = i + 3;
              indices[ki++] = i;
              indices[ki++] = i + 3;
              indices[ki++] = i + 1;
            }

            if (arriba) {
              // centro
              let p, p1, nv;
              p = kv/3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = alto/2;

              colores[kc++] = 0;
              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 1;

              p1 = kv/3;

              // Circulo de arriba
              for (i = 1, j = 0; j <= cantidadDeSectores; i += 2, j++) {
                nv = i * 3;
                vertices[kv++] = vertices[nv];
                vertices[kv++] = vertices[nv+1];
                vertices[kv++] = vertices[nv+2];

                colores[kc++] = 0;
                colores[kc++] = 1;
                colores[kc++] = 0;
                colores[kc++] = 1;
              }

              /**
               *             1
               *           / | 
               *         /   |
               *       /     |
               *    p ------- 1
               *    p,1,3  =>  3  indices
               */
              for (j = 0; j < cantidadDeSectores; j++) {
                indices[ki++] = p;       // p
                indices[ki++] = p1;      // 0
                indices[ki++] = p1+1;    // 1
                p1++;
              }
            }

            if (abajo) {
              // centro
              let p, p1, nv;
              p = kv/3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = -alto/2;

              colores[kc++] = 0;
              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 1;

              p1 = kv/3;

              // Circulo de abajo
              for (i = 0, j = 0; j <= cantidadDeSectores; i += 2, j++) {
                nv = i * 3;
                vertices[kv++] = vertices[nv];
                vertices[kv++] = vertices[nv+1];
                vertices[kv++] = vertices[nv+2];

                colores[kc++] = 0;
                colores[kc++] = 1;
                colores[kc++] = 0;
                colores[kc++] = 1;
              }              

              /**
               *             1
               *           / | 
               *         /   |
               *       /     |
               *    p ------- 0
               *    p,0,2  =>  3  indices
               */

              for (j = 0; j < cantidadDeSectores; j++) {
                indices[ki++] = p;
                indices[ki++] = p1;
                indices[ki++] = p1+1;
                p1++;
              }
            }

            console.log("cant triangulos: ",cantidadDeTriangulos);
            console.log("cant vertices: ",cantidadDeVertices);
            console.log("vertices: ",vertices.length/3);
            for (let i = 0; i < vertices.length; i+=3) {
              console.log(i/3 + " : " + vertices[i] + "  " + vertices[i+1] + "  " + vertices[i+2])
            }

            console.log("indices: ",indices.length);
            for (let i = 0; i < indices.length; i+=6) {
              console.log(i + " : " + indices[i] + "  " + indices[i+1] + "  " + indices[i+2] + "  " + indices[i+3] + "  " + indices[i+4] + "  " + indices[i+5])
            }

            this.cilindroVAO = gl.createVertexArray();
            gl.bindVertexArray(this.cilindroVAO);

            var verticeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var indiceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.cilindroVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }

      class Cono {

          /* segmentosH = slices o longitud, segmentosV = stacks o latitud  */
          constructor(gl, radioArriba, radioAbajo, alto, cantidadDeSectores, arriba, abajo) {

            var i, j, kv, kc, ki, angulo, x, y;

            var cantidadDeVertices = 4 * cantidadDeSectores + 6;
            var cantidadDeTriangulos = 2 * cantidadDeSectores;
            
            if (arriba) {
              cantidadDeTriangulos += cantidadDeSectores;
            }

            if (abajo) {
              cantidadDeTriangulos += cantidadDeSectores;
            }
            this.cantidadDeIndices = cantidadDeTriangulos * 3;

            /* Las coordenadas cartesianas (x, y, z) */
            var vertices = new Float32Array(cantidadDeVertices * 3);

            /* Los colores x c/vértice (r,g,b,a) */
            var colores = new Float32Array(cantidadDeVertices * 4);

            /* Indices */
            var indices = new Uint16Array(this.cantidadDeIndices); 

            /* Se leen los vertices */
            kv = 0;
            kc = 0;
            var anguloDelSector = 2 * Math.PI / cantidadDeSectores; // 1 vuelta (en radianes)/cantidad de sectores

            // Circulo de arriba
            for (i = 0; i <= cantidadDeSectores; i++) {
              angulo = i * anguloDelSector;

              x = Math.cos(angulo);
              y = Math.sin(angulo);

              vertices[kv++] = radioArriba * x;
              vertices[kv++] = radioArriba * y;
              vertices[kv++] = alto/2;

              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 0;
              colores[kc++] = 1;
            }

            // Circulo de abajo
            for (i = 0; i <= cantidadDeSectores; i++) {
              angulo = i * anguloDelSector;

              x = Math.cos(angulo);
              y = Math.sin(angulo);

              vertices[kv++] = radioAbajo * x;
              vertices[kv++] = radioAbajo * y;
              vertices[kv++] = -alto/2;

              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 0;
              colores[kc++] = 1;
            }

            /* Se leen los indices */
     	
            /**
             *  ki1 ------- ki1+1
             *     |     / | 
             *     |   /   |
             *     | /     |
             *  ki2 ------- ki2+1
             *  ki1,ki2,ki1+1, ki1+1,ki2,ki2+1 =>  2 triangulo
             */
            ki = 0
            let ki1 = 0;
            let ki2 = cantidadDeSectores + 1;
            for (j = 0; j < cantidadDeSectores; j++) {
              // ki2 => ki1+1 => ki1 
              indices[ki++] = ki2;
              indices[ki++] = ki1 + 1;
              indices[ki++] = ki1;

              // ki2 => ki2+1 => ki1+1 
              indices[ki++] = ki2;
              indices[ki++] = ki2 + 1;
              indices[ki++] = ki1 + 1;
              ki1++;
              ki2++;
            }

            if (arriba) {
              // centro
              let p, p1, nv;
              p = kv/3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = alto/2;

              colores[kc++] = 0;
              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 1;

              p1 = kv/3;

              // Circulo de arriba
              for (i = 0; i <= cantidadDeSectores; i++) {
                nv = i * 3;
                vertices[kv++] = vertices[nv];
                vertices[kv++] = vertices[nv+1];
                vertices[kv++] = vertices[nv+2];

                colores[kc++] = 0;
                colores[kc++] = 1;
                colores[kc++] = 0;
                colores[kc++] = 1;
              }

              /**
               *             1
               *           / | 
               *         /   |
               *       /     |
               *    p ------- 0
               *    p,0,1  =>  3  indices
               */
              for (i = 0; i < cantidadDeSectores; i++) {
                indices[ki++] = p;       // p
                indices[ki++] = p1;      // 0
                indices[ki++] = p1+1;    // 1
                p1++;
              }
            }

            if (abajo) {
              // centro
              let p, p1, nv;
              p = kv/3;
              vertices[kv++] = 0;
              vertices[kv++] = 0;
              vertices[kv++] = -alto/2;

              colores[kc++] = 0;
              colores[kc++] = 1;
              colores[kc++] = 0;
              colores[kc++] = 1;

              p1 = kv/3;
              j = cantidadDeSectores + 1;                 

              // Circulo de abajo
              for (i = 0; i <= cantidadDeSectores; i++) {
                nv = j * 3;
                vertices[kv++] = vertices[nv];
                vertices[kv++] = vertices[nv+1];
                vertices[kv++] = vertices[nv+2];

                colores[kc++] = 0;
                colores[kc++] = 1;
                colores[kc++] = 0;
                colores[kc++] = 1;
                j++;
              }

              /**
               *             1
               *           / | 
               *         /   |
               *       /     |
               *    p ------- 0
               *    p,0,2  =>  3  indices
               */
               for (i = 0; i < cantidadDeSectores; i++) {
                 indices[ki++] = p;     // p
                 indices[ki++] = p1;    // ki2
                 indices[ki++] = p1+1;  // ki2 + 1
                 p1++;
              }
            }

            console.log("Cant. triangulos: ",cantidadDeTriangulos);
            console.log("Cant. vertices: ",cantidadDeVertices);
            console.log("vertices: ",vertices.length/3);
            for (let i = 0; i < vertices.length; i+=3) {
              console.log(i/3 + " : " + vertices[i] + "  " + vertices[i+1] + "  " + vertices[i+2])
            }

            console.log("indices: ",indices.length);
            for (let i = 0; i < indices.length; i+=6) {
              console.log(i + " : " + indices[i] + "  " + indices[i+1] + "  " + indices[i+2] + "  " + indices[i+3] + "  " + indices[i+4] + "  " + indices[i+5])
            }

            this.cilindroVAO = gl.createVertexArray();
            gl.bindVertexArray(this.cilindroVAO);

            var verticeBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            var codigoColores = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            var indiceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
          }

          dibuja(gl) {
            gl.bindVertexArray(this.cilindroVAO);
            gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
        }

    class ObjetoOBJ {
      constructor(gl, data) {
        this.numIndices = data.indices.length;
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);

        // Vértices
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.positions), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        // Colores (blanco por defecto)
        const colores = [];
        for (let i = 0; i < data.positions.length / 3; i++) {
          colores.push(1, 1, 1, 1);
        }
        const cbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        // Índices
        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data.indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.vao);
        gl.drawElements(gl.TRIANGLES, this.numIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }
    
    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function mouseDown(event) {
      if (!arcballControl && event.button == 0) return false; // Deshabilita ArcBall si el checkbox está apagado
      if (!moveModel && event.button == 2) return false;      // Deshabilita mover si el checkbox está apagado

      var posx = new Number();
      var posy = new Number();

      /* Obtiene la coordenada dentro de la área mayor */
      if (event.x != undefined && event.y != undefined) {
        posx = event.x;
        posy = event.y;
      } else {
        posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      /* Obtiene la coordenada dentro del canvas */
      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (event.button == 0 && arcballControl){ // botón izquierdo
        Matriz = MatrizRotacion.slice(); /* Copia */
        arcBall.primerPunto(posx, posy);
        boton_izq_presionado = true;
      } else if (event.button == 2 && moveModel) // botón derecho
        boton_der_presionado = true;

      return false;
    };

    function mouseUp(e){
      boton_izq_presionado = false;
      boton_der_presionado = false;
    };

    function mouseMove(event) {
      if (!arcballControl && boton_izq_presionado) return; // Deshabilita ArcBall si el checkbox está apagado
      if (!moveModel && boton_der_presionado) return;      // Deshabilita mover si el checkbox está apagado

      var posx = new Number();
      var posy = new Number();

      /* Obtiene la coordenada dentro de la área mayor */
      if (event.x != undefined && event.y != undefined) {
        posx = event.x;
        posy = event.y;
      } else {
        posx = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
        posy = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      }

      /* Obtiene la coordenada dentro del canvas */
      posx = posx - canvas.offsetLeft;
      posy = posy - canvas.offsetTop;

      if (boton_izq_presionado && arcballControl) {
        let q = arcBall.segundoPunto(posx, posy);
        Cuaternion.rota2(MatrizRotacion, q);
        multiplica(MatrizRotacion, MatrizRotacion, Matriz);
      } else if (boton_der_presionado && moveModel){
        posx = (posx * 10 / canvas.width) - 5;
        posy = (10 - posy * 10 / canvas.height) - 5;
        tx = posx;
        ty = posy;
      }
    };

    function zoom(event) {
      event.preventDefault();
      if (event.deltaY > 0){
        sx = sx * 0.9;
        sy = sy * 0.9;
        sz = sz * 0.9;
      } else {
        sx = sx * 1.1;
        sy = sy * 1.1;
        sz = sz * 1.1;
      }  
    };

    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (autoRotateY) rotacionY(MatrizRotacion, 0.5);
      if (autoRotateX) rotacionX(MatrizRotacion, 0.5);

      identidad(MatrizModelo);
      traslacion(MatrizModelo, tx, ty, 0);
      escalacion(MatrizModelo, sx, sy, sz);
      escalacion(MatrizModelo, 2, 2, 2);   
      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      if (objetoActual === "cubo") {
        cubo.dibuja(gl);
      } else if (objetoActual === "cilindro") {
        cilindro.dibuja(gl);
      } else if (objetoActual === "cono") {
        cono.dibuja(gl);
      } else if (objetoActual === "obj" && objetoOBJ) {
        objetoOBJ.dibuja(gl);
      }

      if (showAxes) dibujaEjes(gl);

      requestAnimationFrame(dibuja);
    }

    function dibujaEjes(gl) {
      // Ejes: X (rojo), Y (verde), Z (azul)
      const ejeVertices = new Float32Array([
        // X
        0, 0, 0,   3, 0, 0,
        // Y
        0, 0, 0,   0, 3, 0,
        // Z
        0, 0, 0,   0, 0, 3
      ]);
      const ejeColores = new Float32Array([
        1,0,0,1, 1,0,0,1, // X rojo
        0,1,0,1, 0,1,0,1, // Y verde
        0,0,1,1, 0,0,1,1  // Z azul
      ]);

      // Guarda el estado actual
      gl.useProgram(programaID);

      // Crea buffers temporales
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, ejeVertices, gl.STREAM_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      const cbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
      gl.bufferData(gl.ARRAY_BUFFER, ejeColores, gl.STREAM_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

      // Dibuja las líneas
      gl.drawArrays(gl.LINES, 0, 6);

      // Limpia
      gl.deleteBuffer(vbo);
      gl.deleteBuffer(cbo);
      gl.bindVertexArray(null);
      gl.deleteVertexArray(vao);
    }

    function reinicia() {
      tx = 0; ty = 0;
      sx = 1, sy = 1, sz = 1;
      identidad(MatrizRotacion);

      dibuja();
    }

    function main() {
      canvas = document.getElementById("webglcanvas");
      resizeCanvas(); // <-- Asegura el tamaño correcto al iniciar
      gl = canvas.getContext("webgl2");
      if (!gl) {
         document.write("WebGL 2.0 no está disponible en tu navegador");
         return;
      }
      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup", mouseUp, false);
      canvas.addEventListener("mouseout", mouseUp, false);
      canvas.addEventListener("mousemove", mouseMove, false);
      canvas.addEventListener("wheel", zoom, { passive: false });
      document.getElementById("reset").onclick = reinicia;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      compilaEnlazaLosShaders();

      cubo = new Cubo(gl);
      cilindro = new Cilindro(gl, 1, 2, 32, true, true);
      // cilindro = new Cilindro(gl, 1, 4, 24, true, true);
      cono = new Cono(gl, 1, 0, 2, 32, true, true);
      // cono = new Cono(gl, 1, 0, 4, 24, true, true);

      arcBall = new ArcBall(500.0, 500.0);

      gl.useProgram(programaID);
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      ortho(MatrizProyeccion, -5, 5, -5, 5, -5, 5);
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      identidad(MatrizVista);
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      identidad(MatrizRotacion);
      arcBall.ajusta(gl.canvas.width, gl.canvas.height);
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      dibuja();
    }
    
    // Escuchar los checkboxes y botones después de cargar la página
    window.onload = function() {
      main();
      document.getElementById("autoRotateX").addEventListener("change", function() {
        autoRotateX = this.checked;
      });
      document.getElementById("autoRotateY").addEventListener("change", function() {
        autoRotateY = this.checked;
      });
      document.getElementById("arcballControl").addEventListener("change", function() {
        arcballControl = this.checked;
      });
      document.getElementById("moveModel").addEventListener("change", function() {
        moveModel = this.checked;
      });
      document.getElementById("showAxes").addEventListener("change", function() {
        showAxes = this.checked;
      });
      document.getElementById("scaleUp").addEventListener("click", function() {
        sx *= 1.1; sy *= 1.1; sz *= 1.1;
      });
      document.getElementById("scaleDown").addEventListener("click", function() {
        sx *= 0.9; sy *= 0.9; sz *= 0.9;
      });
      document.getElementById("objeto3d").addEventListener("change", function() {
        objetoActual = this.value;
        if (objetoActual === "obj") {
          document.getElementById("objFile").style.display = "block";
        } else {
          document.getElementById("objFile").style.display = "none";
        }
      });

      document.getElementById("objFile").addEventListener("change", function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
          const data = parseOBJ(evt.target.result);
          objetoOBJ = new ObjetoOBJ(gl, data);
        };
        reader.readAsText(file);
      });
    };

    // Al iniciar, ajusta el tamaño del canvas al contenedor
    function resizeCanvas() {
      const canvas = document.getElementById("webglcanvas");
      const parent = canvas.parentElement;
      canvas.width = parent.clientWidth;
      canvas.height = parent.clientHeight;

      // Si ya tienes el contexto WebGL, ajusta el viewport y la proyección
      if (window.gl) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        // Si usas ortho, puedes recalcular aquí si quieres que se adapte al aspecto
        // Por ejemplo:
        // let aspect = canvas.width / canvas.height;
        // ortho(MatrizProyeccion, -5*aspect, 5*aspect, -5, 5, -5, 5);
        // gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      }
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('DOMContentLoaded', resizeCanvas);

    function parseOBJ(text) {
      const lines = text.split('\n');
      const positions = [];
      const indices = [];
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('v ')) {
          const [, x, y, z] = line.split(/\s+/);
          positions.push(parseFloat(x), parseFloat(y), parseFloat(z));
        } else if (line.startsWith('f ')) {
          const verts = line.split(/\s+/).slice(1);
          if (verts.length === 3) {
            for (let v of verts) {
              const idx = parseInt(v.split('/')[0], 10) - 1;
              indices.push(idx);
            }
          }
        }
      }
      return {positions, indices};
    }
  </script>
</body>
</html>