<!DOCTYPE HTML>
<html>

<head>
  <title>Visor de Modelos 3D</title>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    .container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    .left-panel {
      flex: 1 1 60%;
      display: flex;
      align-items: stretch;
      justify-content: stretch;
      background: #222;
    }

    .right-panel {
      flex: 0 0 340px;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      padding: 32px 24px;
      box-shadow: -2px 0 16px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      min-width: 300px;
      max-width: 400px;
      height: 100vh;
      box-sizing: border-box;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    #webglcanvas {
      border: none;
      background: #000;
      box-shadow: 0 0 12px #0008;
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      display: block;
    }

    .right-panel h2 {
      margin-top: 0;
      margin-bottom: 24px;
      font-size: 1.5em;
      letter-spacing: 1px;
      color: #ffb347;
      text-shadow: 1px 1px 4px #0008;
      text-align: center;
    }

    .menu-group {
      margin-bottom: 7px;
      padding: 5px 0 0 0;
      border-bottom: 1px solid
    }

    .menu-group:last-child {
      border-bottom: none;
    }

    .menu-group label {
      font-size: 1.08em;
      margin-right: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #ffe082;
      font-weight: 500;
    }

    .menu-group input[type="checkbox"] {
      accent-color: #ffb347;
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .menu-group select,
    .menu-group input[type="file"] {
      margin-top: 6px;
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid #ffb347;
      background: #232526;
      color: #fff;
      font-size: 1em;
      outline: none;
      transition: border 0.2s;
    }

    .menu-group select:focus,
    .menu-group input[type="file"]:focus {
      border: 1.5px solid #ffe082;
    }

    .right-panel button {
      padding: 7px 22px;
      font-size: 1.08em;
      border-radius: 8px;
      border: none;
      background: linear-gradient(90deg, #ffb347 0%, #ffcc80 100%);
      color: #232526;
      font-weight: bold;
      cursor: pointer;
      margin-top: 7px;
      margin-bottom: 7px;
      box-shadow: 0 2px 8px #0002;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }

    .right-panel button:hover {
      background: linear-gradient(90deg, #ffe082 0%, #ffb347 100%);
      color: #222;
      transform: scale(1.04);
    }

    .menu-info {
      font-size: 1em;
      color: #ffe082;
      margin-top: 10px;
      background: #232526cc;
      border-radius: 8px;
      padding: 5px 12px;
      box-shadow: 0 1px 6px #0003;
      text-align: center;
      letter-spacing: 0.5px;
    }

    /* Extra: animación de entrada */
    .right-panel {
      animation: fadeInMenu 1s;
      flex: 0 0 425px;
      min-width: 360px;
      max-width: 480px;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      padding: 12px 14px;
      box-shadow: -2px 0 16px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      height: 100vh;
      box-sizing: border-box;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    @keyframes fadeInMenu {
      from {
        opacity: 0;
        transform: translateX(40px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Mejora para input file */
    input[type="file"] {
      display: none;
    }

    .custom-file-label {
      display: inline-block;
      padding: 7px 18px;
      background: linear-gradient(90deg, #ffb347 0%, #ffcc80 100%);
      color: #232526;
      border-radius: 7px;
      font-weight: 500;
      cursor: pointer;
      font-size: 1em;
      margin-bottom: 6px;
      margin-right: 8px;
      box-shadow: 0 2px 8px #0002;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }

    .custom-file-label:hover {
      background: linear-gradient(90deg, #ffe082 0%, #ffb347 100%);
      color: #222;
      transform: scale(1.04);
    }

    /* Mejora para radio de material */
    #materialOptions label {
      background: #333;
      border-radius: 6px;
      padding: 4px 12px;
      margin-right: 8px;
      transition: background 0.2s, color 0.2s;
      cursor: pointer;
      font-size: 1em;
      color: #ffe082;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    #materialOptions input[type="radio"] {
      accent-color: #ffb347;
      width: 18px;
      height: 18px;
      margin-right: 4px;
    }

    #materialOptions label:hover,
    #materialOptions input[type="radio"]:checked+label {
      background: #444;
      color: #ffb347;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="left-panel">
      <canvas id="webglcanvas" oncontextmenu="return false;"></canvas>
    </div>
    <div class="right-panel">
      <h2>Visor 3D</h2>
      <div class="menu-group">
        <label>
          <input type="checkbox" id="autoRotateY">
          Rotar automáticamente en Y
        </label>
        <label>
          <input type="checkbox" id="autoRotateX">
          Rotar automáticamente en X
        </label>
        <label>
          <input type="checkbox" id="arcballControl" checked>
          Control manual (ArcBall)
        </label>
        <label>
          <input type="checkbox" id="moveModel">
          Mover modelo (botón derecho)
        </label>
        <label>
          <input type="checkbox" id="showAxes">
          Mostrar ejes XYZ
        </label>
        <div class="menu-group" id="pisoOpcionesGroup">
          <label>
            <input type="checkbox" id="mostrarPiso">
            Agregar Piso
          </label>
        </div>
      </div>

      <div class="menu-group" style="display: flex; gap: 10px; align-items: center;">
        <button id="reset" style="flex:1;">Resetear vista</button>
        <label style="margin:0 0 0 10px;">Escalar:</label>
        <button id="scaleUp" title="Agrandar">+</button>
        <button id="scaleDown" title="Reducir">−</button>
      </div>

      <div class="menu-group">
        <label for="objeto3d" style="margin-bottom: 6px;">Objeto:</label>
        <select id="objeto3d" style="margin-bottom: 8px;">
          <option value="cubo">Cubo</option>
          <option value="cilindro">Cilindro</option>
          <option value="cono">Cono</option>
          <option value="esfera">Esfera</option>
          <option value="obj">OBJ</option>
        </select>
        <div style="margin-top:8px;">
          <label for="objFile" class="custom-file-label" id="objFileLabel" style="display:none;">OBJ</label>
          <input type="file" id="objFile" accept=".obj" style="display:none;">
          <label for="textureFile" class="custom-file-label" id="textureFileLabel"
            style="display:inline-block;">TEXTURA</label>
          <input type="file" id="textureFile" accept="image/*" style="display:none;">
        </div>
        <div id="materialOptions" style="display:block; margin-top:8px;"> 
          <label><input type="radio" name="materialType" value="color" checked> Color (MTL)</label>
          <label><input type="radio" name="materialType" value="texture"> Textura</label>
        </div>
      </div>

      <div class="menu-group" id="proyeccionOpcionesGroup">
        <label>
          <input type="checkbox" id="proyeccionParalela" checked>
          Proyección Paralela
        </label>
        <label>
          <input type="checkbox" id="proyeccionFrustum">
          Proyección Perspectiva (frustum)
        </label>
      </div>

      <div class="menu-info">
        <b>Zoom:</b> Rueda del mouse<br>
        <b>Rotar:</b> Botón izquierdo<br>
        <b>Trasladar:</b> Botón derecho<br>
        <b>ArcBall:</b> Activa/desactiva con el checkbox<br>
      </div>
    </div>
  </div>

  <!--
    /***************************************************************************/
    /* Se definen los códigos shaders.                                         */
    /***************************************************************************/
  -->
  <script id="vs" type="vertex">
    #version 300 es
    uniform mat4 uMatrizProyeccion;
    uniform mat4 uMatrizVista;
    uniform mat4 uMatrizModelo;
    layout(location = 0) in vec3 aVertices;
    layout(location = 1) in vec4 aColores;
    layout(location = 2) in vec2 aUV;
    out vec4 vColores;
    out vec2 vUV;
    void main() {
      vColores = aColores;  
      vUV = aUV;
      gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
    }
  </script>

  <script id="fs" type="fragment">
    #version 300 es
    precision highp float;
    in vec4 vColores;
    in vec2 vUV;
    uniform sampler2D uSampler;
    uniform bool uUseTexture;
    out vec4 color;
    void main() {
        if(uUseTexture)
          color = texture(uSampler, vUV);
        else
          color = vColores;
    }
  </script>

  <script>
    "use strict";

    /* Variables globales */
    var canvas;
    var programaID;
    var gl;
    var cubo;
    var arcBall;
    var autoRotate = false;    // Rotación automática en Y
    var autoRotateX = false;   // Rotación automática en X
    var autoRotateY = false;   // Rotación automática en Y
    var arcballControl = true; // Controla si el ArcBall está activo
    var moveModel = false; // Controla si la traslación con botón derecho está activa
    var showAxes = false; // Mostrar/Ocultar ejes XYZ
    var wireframe = false; // Mostrar como malla
    var objetoActual = "cubo";
    var cilindro, cono;
    var objetoOBJ = null;
    var piso = null;
    var esfera = null;

    /* Variables Uniformes */
    var uMatrizProyeccion;
    var uMatrizVista;
    var uMatrizModelo;
    var uUseTexture, uSampler;

    /* Matrices */
    var MatrizProyeccion = new Array(16);
    var MatrizVista = new Array(16);
    var MatrizModelo = new Array(16);

    /* Para la interacción */
    var tx = 0, ty = 0;
    var sx = 1, sy = 1, sz = 1;
    var MatrizRotacion = new Array(16);
    var Matriz = new Array(16);
    var boton_izq_presionado = false;
    var boton_der_presionado = false;

    var usarTextura = false;
    var textura = null;
    var mtlMaterials = {};

    // Variable global para el código de textura
    var codigoDeTextura = null;

    /***************************************************************************/
    /* Se crean, compilan y enlazan los programas Shader                       */
    /***************************************************************************/
    function compilaEnlazaLosShaders() {

      /* Se compila el shader de vertice */
      var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(shaderDeVertice, document.getElementById("vs").text.trim());
      gl.compileShader(shaderDeVertice);
      if (!gl.getShaderParameter(shaderDeVertice, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shaderDeVertice));
      }

      /* Se compila el shader de fragmento */
      var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shaderDeFragmento, document.getElementById("fs").text.trim());
      gl.compileShader(shaderDeFragmento);
      if (!gl.getShaderParameter(shaderDeFragmento, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shaderDeFragmento));
      }

      /* Se enlaza ambos shader */
      programaID = gl.createProgram();
      gl.attachShader(programaID, shaderDeVertice);
      gl.attachShader(programaID, shaderDeFragmento);
      gl.linkProgram(programaID);
      if (!gl.getProgramParameter(programaID, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(programaID));
      }

      /* Se instala el programa de shaders para utilizarlo */
      gl.useProgram(programaID);
    }

    /***************************************************************************/
    /* Transformaciones mediante matrices                                      */
    /***************************************************************************/

    /* Convierte de grados a radianes */
    function toRadians(grados) {
      return grados * Math.PI / 180;
    };

    /* Matriz Identidad */
    function identidad(r) {
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /* Traslación - glTranslatef */
    function traslacion(matriz, tx, ty, tz) {
      var r = new Array(16);
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = tx;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = ty;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Escalación - glScalef */
    function escalacion(matriz, sx, sy, sz) {
      var r = new Array(16);
      r[0] = sx; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = sy; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = sz; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre X - glRotatef */
    function rotacionX(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = c; r[9] = -s; r[13] = 0;
      r[2] = 0; r[6] = s; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre Y - glRotatef */
    function rotacionY(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = 0; r[8] = s; r[12] = 0;
      r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
      r[2] = -s; r[6] = 0; r[10] = c; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Rotación sobre Z - glRotatef */
    function rotacionZ(matriz, theta) {
      let r = new Array(16);
      var c = Math.cos(toRadians(theta));
      var s = Math.sin(toRadians(theta));
      r[0] = c; r[4] = -s; r[8] = 0; r[12] = 0;
      r[1] = s; r[5] = c; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
      multiplica(matriz, matriz, r);
    }

    /* Proyección Paralela - glOrtho */
    function ortho(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2 / (der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq) / (der - izq);
      r[1] = 0; r[5] = 2 / (arr - abj); r[9] = 0; r[13] = -(arr + abj) / (arr - abj);
      r[2] = 0; r[6] = 0; r[10] = -2 / (lejos - cerca); r[14] = -(lejos + cerca) / (lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
    }

    /* Proyección Perspectiva - glFrustum */
    function frustum(r, izq, der, abj, arr, cerca, lejos) {
      r[0] = 2 * cerca / (der - izq); r[4] = 0; r[8] = (der + izq) / (der - izq); r[12] = 0;
      r[1] = 0; r[5] = 2 * cerca / (arr - abj); r[9] = (arr + abj) / (arr - abj); r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] = -2 * lejos * cerca / (lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = -1; r[15] = 0;
    }

    /* Proyección Perspectiva - gluPerspective */
    function perspective(r, fovy, aspecto, cerca, lejos) {
      var ang = fovy * 0.5;
      var f = (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) / Math.tan(toRadians(ang));
      r[0] = f / aspecto; r[4] = 0; r[8] = 0; r[12] = 0;
      r[1] = 0; r[5] = f; r[9] = 0; r[13] = 0;
      r[2] = 0; r[6] = 0; r[10] = -(lejos + cerca) / (lejos - cerca); r[14] = -2.0 * lejos * cerca / (lejos - cerca);
      r[3] = 0; r[7] = 0; r[11] = - 1.0; r[15] = 0;
    }

    /* Multiplicación de matrices de 4 x 4 */
    function multiplica(c, a, b) {
      let r = new Array(16);
      let i, j, k;
      for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
          let s = 0;
          for (k = 0; k < 4; k++)
            s = s + a[i + k * 4] * b[k + j * 4];
          r[i + j * 4] = s;
        }
      }
      for (i = 0; i < 16; i++)
        c[i] = r[i];
    }

    /***************************************************************************/
    /* La Clase Vector3                                                        */
    /***************************************************************************/

    class Vector3 {

      /**
       * Construye un nuevo Vector.
       */
      constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
      }

      /**
       *                   u = Suma de vectores
       *  u = v1 + v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                   u = (v1.x + v2.x, v1.y + v2.y, v1.z + v2.z)
       */
      mas(v2) {
        return (new Vector3(this.x + v2.x, this.y + v2.y, this.z + v2.z));
      }

      /**
       *                   u = Resta de vectores
       *  u = v1 - v2     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                   u = (v1.x - v2.x, v1.y - v2.y, v1.z - v2.z)
       */
      menos(v2) {
        return (new Vector3(this.x - v2.x, this.y - v2.y, this.z - v2.z));
      }

      /**
       *                      u x v = Producto vectorial o producto cruz
       * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       * v = (v.x, v.y, v.z)  u x v = (u.y * v.z - u.z * v.y,   
       *                               u.z * v.x - u.x * v.z,
       *                               u.x * v.y - u.y * v.x)                  
       */
      producto_vectorial(v2) {
        var r = new Vector3();
        r.x = (this.y * v2.z) - (this.z * v2.y);
        r.y = (this.z * v2.x) - (this.x * v2.z);
        r.z = (this.x * v2.y) - (this.y * v2.x);
        return r;
      }

      /**
       *                      u . v = Producto escalar o producto punto
       * u = (u.x, u.y, u.z) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       * v = (v.x, v.y, v.z)  u . v = u.x v.x + u.y v.y + u.z v.z
       *                                          
       */
      producto_escalar(v2) {
        return (this.x * v2.x) + (this.y * v2.y) + (this.z * v2.z);
      }

      /**
       *                     |v| = Longitud de un vector o magnitud
       * v = (x, y, z)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *                     |v| = raiz_cuadrada (x^2 + y^2 + z^2) 
       *                                          
       */
      longitud() {
        return (Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z));
      }

      /**
       *        v            u = Vector unitario o de longitud 1
       *  u  = ---        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       *       |v|           u = Vector normalizado
       *                     
       */
      normaliza() {
        var l = this.longitud();
        if (l > 0) {
          this.x = this.x / l;
          this.y = this.y / l;
          this.z = this.z / l;
        }
      }
      /**
       *    3
       *     ^
       *     |
       *   v |
       *     |
       *    1 -------- > 2
       */
      normal(v1, v2, v3) {
        var u = new Vector3(); // vector u
        var v = new Vector3(); // vector v
        var n = new Vector3(); // vector n

        /* Calcula los vectores u y v */
        u = v2.menos(v1);
        v = v3.menos(v1);

        /* n = u x v */
        n = u.producto_vectorial(v);

        /* Normaliza */
        n.normaliza();

        return n;
      }

      toString() {
        return "Vector3 [x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***************************************************************************/
    /* ArcBall: Obtiene los vectores U y V de la esfera (x^2 + y^2 + z^2 = 1). */
    /***************************************************************************/

    var Punto2f = function (x, y) {
      // Atributos publicos
      this.x = x;
      this.y = y;
    }

    class ArcBall {

      /**
       * Construye un nuevo ArcBall.
       */
      constructor(w, h) {
        this.Epsilon = 1.0e-5;
        this.U = new Vector3();
        this.V = new Vector3();
        this.ajusta(w, h);
      }

      /* Ajusta el ancho y alto de la ventana */
      ajusta(w, h) {
        if (!((w > 1.0) && (h > 1.0)))
          document.write("ERROR");

        /* Ajusta el factor para el ancho y alto (2 = [-1..1]) */
        this.ajustaAncho = 2.0 / (w - 1.0);
        this.ajustaAlto = 2.0 / (h - 1.0);
      }

      /* Obtiene el vector dado un punto (x,y) */
      obtieneVector(vector, x, y) {
        /* Copia punto */
        let temp = new Punto2f(x, y);

        /* Ajusta las coordenadas del punto al rango [-1..1] */
        temp.x = (temp.x * this.ajustaAncho) - 1.0;
        temp.y = 1.0 - (temp.y * this.ajustaAlto);

        /* Calcula el cuadrado de la longitud del vector */
        let longitud2 = (temp.x * temp.x) + (temp.y * temp.y);

        /* 
         * Considerando que: radio^2 = x^2 + y^2 + z^2
         * ¿Cuales son los valores de x, y y z?
         * 
         * Si el punto está fuera de la esfera... (longitud2 > 1)
         */

        if (longitud2 > 1.0) {
          /* Calcula un factor de normalización (radio / sqrt(longitud2)) */
          let norma = (1.0 / Math.sqrt(longitud2));

          /* Retorna el vector "normalizado", un punto sobre la esfera */
          vector.x = temp.x * norma;
          vector.y = temp.y * norma;
          vector.z = 0.0;
        } else { /* e.o.c. está dentro */
          /*
           * Retorna un vector, un punto dentro la esfera 
           * z = sqrt(radio^cuadrado - (x^2 + y^2))
           */
          vector.x = temp.x;
          vector.y = temp.y;
          vector.z = Math.sqrt(1.0 - longitud2);
        }
      }

      /* Obtiene el vector U */
      primerPunto(x, y) {
        this.obtieneVector(this.U, x, y);
      }

      /* Obtiene el Cuaternion de U y V */
      segundoPunto(x, y) {

        let q = new Cuaternion();

        /* Obtiene el vector V */
        this.obtieneVector(this.V, x, y);

        /* Retorna el cuaternión equivalente a la rotación. */
        if (q != null) {

          /* Calcula la Normal = U x V */
          let Normal = this.U.producto_vectorial(this.V);

          /* Calcula la longitud de la normal */
          if (Normal.longitud() > this.Epsilon) { /* si no es cero */
            q.x = Normal.x;
            q.y = Normal.y;
            q.z = Normal.z;
            /* w  = (theta / 2), donde theta es el ángulo de rotación */
            q.w = this.U.producto_escalar(this.V);
          } else { /* si es cero */
            /* U y V coinciden */
            q.x = q.y = q.z = q.w = 0.0;
          }
        }
        return q;
      }
    }

    /***************************************************************************/
    /* Cuaternion: Realiza las operaciones de los cuaterniones.                */
    /***************************************************************************/

    class Cuaternion {

      /**
       * Construye un nuevo Cuaternion.
       */
      constructor(w, x, y, z) {
        this.w = w;
        this.x = x;
        this.y = y;
        this.z = z;
      }

      inicializa(w, v) {
        this.w = w;
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
      }

      // norma^2 = w^2 + x^2 + y^2 + z^2
      norma2() {
        return (this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
      }

      // Conjugado
      conjugado() {
        x = -this.x;
        y = -this.y;
        z = -this.z;
        return this;
      }

      // Cuaternion q = Cuaternion a . Cuaternion b
      multiplica(a, b) {
        let q = new Cuaternion(0, 0, 0, 0);
        q.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        q.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;
        q.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;
        q.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;
        return q;
      }

      // Cuaternion q = Cuaternion a . b
      multiplica_escalar(a, b) {
        let q = new Cuaternion(0, 0, 0, 0);
        q.w = a.w * b;
        q.x = a.x * b;
        q.y = a.y * b;
        q.z = a.z * b;
        return q;
      }

      // q' = q . p . q^(-1)
      rota(q, p) {   // q es Cuaternion y p es Vector3
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.inverso()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }

      // q' = q . p . q*
      rota1(q, p) {  // q es Cuaternion y p es Vector3
        let p_homogeneo = new Cuaternion(0, 0, 0, 0);
        p_homogeneo.inicializa(0, p);
        let p_prima = this.multiplica(q, this.multiplica(p_homogeneo, q.conjugado()));
        return (new Vector3(p_prima.x, p_prima.y, p_prima.z));
      }

      // q = q^(-1)
      inverso() {
        let q = new Cuaternion(0, 0, 0, 0);
        // normal^2 = a . b
        let n = this.norma2();
        if (n <= 1e-8)
          document.write("INVERSO: Error");
        q = multiplica_escalar(new Cuaternion(this.w, -this.x, -this.y, -this.z), 1 / n);
        return q;
      }

      /* Convierte el cuaternión a una matriz de rotación */
      static rota2(a, q) {
        let d, s;
        d = (q.x * q.x) + (q.y * q.y) + (q.z * q.z) + (q.w * q.w);
        s = (d > 0.0) ? (2.0 / d) : 0.0;
        a[0] = 1.0 - (q.y * q.y + q.z * q.z) * s; a[4] = (q.x * q.y - q.w * q.z) * s; a[8] = (q.x * q.z + q.w * q.y) * s; a[12] = 0;
        a[1] = (q.x * q.y + q.w * q.z) * s; a[5] = 1.0 - (q.x * q.x + q.z * q.z) * s; a[9] = (q.y * q.z - q.w * q.x) * s; a[13] = 0;
        a[2] = (q.x * q.z - q.w * q.y) * s; a[6] = (q.y * q.z + q.w * q.x) * s; a[10] = 1.0 - (q.x * q.x + q.y * q.y) * s; a[14] = 0;
        a[3] = 0; a[7] = 0; a[11] = 0; a[15] = 1;
      }

      toString() {
        return "Cuaternion [w=" + this.w + ", x=" + this.x + ", y=" + this.y + ", z=" + this.z + "]";
      }
    }

    /***********************************************************************************/
    /* Se define la geometría y se almacenan en
    /***********************************************************************************/
    class Piso {
      constructor(gl, r, g, b) {
        /**
         *    3 ----- 2
         *     |   / |
         *     | /   |
         *    0 ----- 1
         */

        /* Las coordenadas cartesianas (x, y) */
        var vertices = new Array(42 * 6);

        /* Lee los colores x vértice (r,g,b,a) */
        var colores = new Array(42 * 8);

        var i = 0;
        var j = 0;
        for (var x = -10; x <= 10; x++) {
          vertices[i] = x; vertices[i + 1] = -1; vertices[i + 2] = 10;
          vertices[i + 3] = x; vertices[i + 4] = -1; vertices[i + 5] = -10;
          i = i + 6;
          colores[j] = r; colores[j + 1] = g; colores[j + 2] = b; colores[j + 3] = 1;
          colores[j + 4] = r; colores[j + 5] = g; colores[j + 6] = b; colores[j + 7] = 1;
          j = j + 8;
        }
        for (var z = 10; z >= -10; z--) {
          vertices[i] = -10; vertices[i + 1] = -1; vertices[i + 2] = z;
          vertices[i + 3] = 10; vertices[i + 4] = -1; vertices[i + 5] = z;
          i = i + 6;
          colores[j] = r; colores[j + 1] = g; colores[j + 2] = b; colores[j + 3] = 1;
          colores[j + 4] = r; colores[j + 5] = g; colores[j + 6] = b; colores[j + 7] = 1;
          j = j + 8;
        }

        this.rectanguloVAO = gl.createVertexArray();
        gl.bindVertexArray(this.rectanguloVAO);

        var verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        var colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.rectanguloVAO);
        gl.drawArrays(gl.LINES, 0, 84);
        gl.bindVertexArray(null);
      }
    }

    class Cubo {
      constructor(gl) {

        /**
         *       3 --------- 2
         *       /|        /|   
         *      / |       / |
         *    7 --------- 6 |
         *     |  |      |  |
         *     | 0 ------|-- 1 
         *     | /       | /
         *     |/        |/
         *    4 --------- 5  
         */

        /* Las coordenadas cartesianas (x, y, z) */
        var vertices = [
          // Frente
          -1, -1, 1, // 4   0
          1, -1, 1, // 5   1
          1, 1, 1, // 6   2
          -1, 1, 1, // 7   3
          // Atrás
          -1, 1, -1, // 3   4
          1, 1, -1, // 2   5
          1, -1, -1, // 1   6
          -1, -1, -1, // 0   7
          // Izquierda
          -1, -1, -1, // 0   8
          -1, -1, 1, // 4   9
          -1, 1, 1, // 7  10 
          -1, 1, -1, // 3  11
          // Derecha
          1, -1, 1, // 5  12 
          1, -1, -1, // 1  13
          1, 1, -1, // 2  14
          1, 1, 1, // 6  15
          // Abajo
          -1, -1, -1, // 0  16
          1, -1, -1, // 1  17
          1, -1, 1, // 5  18
          -1, -1, 1, // 4  19
          // Arriba
          -1, 1, 1, // 7  20
          1, 1, 1, // 6  21
          1, 1, -1, // 2  22
          -1, 1, -1  // 3  23
        ];

        /* Los colores x c/vértice (r,g,b,a) */
        var colores = [
          // Frente - lila
          1, 0, 1, 1, // 4   0
          1, 0, 1, 1, // 5   1
          1, 0, 1, 1, // 6   2
          1, 0, 1, 1, // 7   3  
          // Atrás - amarillo
          1, 1, 0, 1, // 3   4  
          1, 1, 0, 1, // 2   5
          1, 1, 0, 1, // 1   6  
          1, 1, 0, 1, // 0   7  
          // Izquierda - celeste
          0, 1, 1, 1, // 0   8
          0, 1, 1, 1, // 4   9
          0, 1, 1, 1, // 7  10
          0, 1, 1, 1, // 3  11
          // Derecha - rojo
          1, 0, 0, 1, // 5  12
          1, 0, 0, 1, // 1  13
          1, 0, 0, 1, // 2  14
          1, 0, 0, 1, // 6  15
          // Abajo - azul
          0, 0, 1, 1, // 0  16
          0, 0, 1, 1, // 1  17
          0, 0, 1, 1, // 5  18
          0, 0, 1, 1, // 4  19
          // Arriba - verde
          0, 1, 0, 1, // 7  20
          0, 1, 0, 1, // 6  21
          0, 1, 0, 1, // 2  22
          0, 1, 0, 1  // 3  23
        ];

        /* UVs */
        var uvs = [
          // Frente
          0, 0, 1, 0, 1, 1, 0, 1,
          // Atrás
          0, 0, 1, 0, 1, 1, 0, 1,
          // Izquierda
          0, 0, 1, 0, 1, 1, 0, 1,
          // Derecha
          0, 0, 1, 0, 1, 1, 0, 1,
          // Abajo
          0, 0, 1, 0, 1, 1, 0, 1,
          // Arriba
          0, 0, 1, 0, 1, 1, 0, 1
        ];

        /* Indices */
        var indices = [
          0, 1, 2, 0, 2, 3, // Frente
          4, 5, 6, 4, 6, 7, // Atrás
          8, 9, 10, 8, 10, 11, // Izquierda 
          12, 13, 14, 12, 14, 15, // Derecha
          16, 17, 18, 16, 18, 19, // Abajo
          20, 21, 22, 20, 22, 23  // Arriba
        ];

        this.cuboVAO = gl.createVertexArray();
        gl.bindVertexArray(this.cuboVAO);

        var codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        var uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

        var codigoDeIndices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.cuboVAO);
        gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class Cilindro {

      /* segmentosH = slices o longitud, segmentosV = stacks o latitud  */
      constructor(gl, radio, alto, cantidadDeSectores, arriba, abajo) {

        var i, j, kv, kc, ki, angulo, x, y;

        var cantidadDeVertices = 4 * cantidadDeSectores + 6;
        var cantidadDeTriangulos = 2 * cantidadDeSectores;

        if (arriba) {
          cantidadDeTriangulos += cantidadDeSectores;
        }

        if (abajo) {
          cantidadDeTriangulos += cantidadDeSectores;
        }
        this.cantidadDeIndices = cantidadDeTriangulos * 3;

        /* Las coordenadas cartesianas (x, y, z) */
        var vertices = new Float32Array(cantidadDeVertices * 3);

        /* Los colores x c/vértice (r,g,b,a) */
        var colores = new Float32Array(cantidadDeVertices * 4);

        /* Indices */
        var indices = new Uint16Array(this.cantidadDeIndices);

        // UVs
        var uvs = new Float32Array(cantidadDeVertices * 2);
        var ku = 0;

        /* Se leen los vertices */
        kv = 0;
        kc = 0;
        var anguloDelSector = 2 * Math.PI / cantidadDeSectores; // 1 vuelta (en radianes)/cantidad de sectores

        // Circulo de arriba y abajo
        for (i = 0; i <= cantidadDeSectores; i++) {
          angulo = i * anguloDelSector;

          x = Math.cos(angulo);
          y = Math.sin(angulo);

          vertices[kv++] = radio * x;
          vertices[kv++] = radio * y;
          vertices[kv++] = -alto / 2;

          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 0;
          colores[kc++] = 1;

          vertices[kv++] = radio * x;
          vertices[kv++] = radio * y;
          vertices[kv++] = alto / 2;

          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 0;
          colores[kc++] = 1;
        }

        // Genera UVs para cada vértice
        // Para los lados
        for (i = 0; i <= cantidadDeSectores; i++) {
          let t = i / cantidadDeSectores;
          // Abajo
          uvs[ku++] = t; uvs[ku++] = 0;
          // Arriba
          uvs[ku++] = t; uvs[ku++] = 1;
        }
        // Para las tapas (arriba y abajo)
        for (let tapa = 0; tapa < 2; tapa++) {
          let y = (tapa === 0) ? 1 : 0;
          // Centro
          uvs[ku++] = 0.5; uvs[ku++] = 0.5;
          for (i = 0; i <= cantidadDeSectores; i++) {
            let angulo = i * anguloDelSector;
            uvs[ku++] = 0.5 + 0.5 * Math.cos(angulo);
            uvs[ku++] = 0.5 + 0.5 * Math.sin(angulo);
          }
        }

        /* Se leen los indices */

        /**
         *    1 ------- 3
         *     |     / | 
         *     |   /   |
         *     | /     |
         *    0 ------- 2
         *    0,2,3, 0,3,1     =>  6 indices
         */
        ki = 0
        for (i = 0, j = 0; j < cantidadDeSectores; i += 2, j++) {
          indices[ki++] = i;
          indices[ki++] = i + 2;
          indices[ki++] = i + 3;
          indices[ki++] = i;
          indices[ki++] = i + 3;
          indices[ki++] = i + 1;
        }

        if (arriba) {
          // centro
          let p, p1, nv;
          p = kv / 3;
          vertices[kv++] = 0;
          vertices[kv++] = 0;
          vertices[kv++] = alto / 2;

          colores[kc++] = 0;
          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 1;

          p1 = kv / 3;

          // Circulo de arriba
          for (i = 1, j = 0; j <= cantidadDeSectores; i += 2, j++) {
            nv = i * 3;
            vertices[kv++] = vertices[nv];
            vertices[kv++] = vertices[nv + 1];
            vertices[kv++] = vertices[nv + 2];

            colores[kc++] = 0;
            colores[kc++] = 1;
            colores[kc++] = 0;
            colores[kc++] = 1;
          }

          /**
           *             1
           *           / | 
           *         /   |
           *       /     |
           *    p ------- 1
           *    p,1,3  =>  3  indices
           */
          for (j = 0; j < cantidadDeSectores; j++) {
            indices[ki++] = p;       // p
            indices[ki++] = p1;      // 0
            indices[ki++] = p1 + 1;    // 1
            p1++;
          }
        }

        if (abajo) {
          // centro
          let p, p1, nv;
          p = kv / 3;
          vertices[kv++] = 0;
          vertices[kv++] = 0;
          vertices[kv++] = -alto / 2;

          colores[kc++] = 0;
          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 1;

          p1 = kv / 3;

          // Circulo de abajo
          for (i = 0, j = 0; j <= cantidadDeSectores; i += 2, j++) {
            nv = i * 3;
            vertices[kv++] = vertices[nv];
            vertices[kv++] = vertices[nv + 1];
            vertices[kv++] = vertices[nv + 2];

            colores[kc++] = 0;
            colores[kc++] = 1;
            colores[kc++] = 0;
            colores[kc++] = 1;
          }

          /**
           *             1
           *           / | 
           *         /   |
           *       /     |
           *    p ------- 0
           *    p,0,2  =>  3  indices
           */

          for (j = 0; j < cantidadDeSectores; j++) {
            indices[ki++] = p;
            indices[ki++] = p1;
            indices[ki++] = p1 + 1;
            p1++;
          }
        }

        console.log("cant triangulos: ", cantidadDeTriangulos);
        console.log("cant vertices: ", cantidadDeVertices);
        console.log("vertices: ", vertices.length / 3);
        for (let i = 0; i < vertices.length; i += 3) {
          console.log(i / 3 + " : " + vertices[i] + "  " + vertices[i + 1] + "  " + vertices[i + 2])
        }

        console.log("indices: ", indices.length);
        for (let i = 0; i < indices.length; i += 6) {
          console.log(i + " : " + indices[i] + "  " + indices[i + 1] + "  " + indices[i + 2] + "  " + indices[i + 3] + "  " + indices[i + 4] + "  " + indices[i + 5])
        }

        this.cilindroVAO = gl.createVertexArray();
        gl.bindVertexArray(this.cilindroVAO);

        var verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        var uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

        var indiceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.cilindroVAO);
        gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class Cono {

      /* segmentosH = slices o longitud, segmentosV = stacks o latitud  */
      constructor(gl, radioArriba, radioAbajo, alto, cantidadDeSectores, arriba, abajo) {

        var i, j, kv, kc, ki, angulo, x, y;

        var cantidadDeVertices = 4 * cantidadDeSectores + 6;
        var cantidadDeTriangulos = 2 * cantidadDeSectores;

        if (arriba) {
          cantidadDeTriangulos += cantidadDeSectores;
        }

        if (abajo) {
          cantidadDeTriangulos += cantidadDeSectores;
        }
        this.cantidadDeIndices = cantidadDeTriangulos * 3;

        /* Las coordenadas cartesianas (x, y, z) */
        var vertices = new Float32Array(cantidadDeVertices * 3);

        /* Los colores x c/vértice (r,g,b,a) */
        var colores = new Float32Array(cantidadDeVertices * 4);

        /* Indices */
        var indices = new Uint16Array(this.cantidadDeIndices);

        // UVs
        var uvs = new Float32Array(cantidadDeVertices * 2);
        var ku = 0;

        /* Se leen los vertices */
        kv = 0;
        kc = 0;
        var anguloDelSector = 2 * Math.PI / cantidadDeSectores; // 1 vuelta (en radianes)/cantidad de sectores

        // Circulo de arriba
        for (i = 0; i <= cantidadDeSectores; i++) {
          angulo = i * anguloDelSector;

          x = Math.cos(angulo);
          y = Math.sin(angulo);

          vertices[kv++] = radioArriba * x;
          vertices[kv++] = radioArriba * y;
          vertices[kv++] = alto / 2;

          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 0;
          colores[kc++] = 1;

          // UVs
          uvs[ku++] = 0.5 + 0.5 * x;
          uvs[ku++] = 0.5 + 0.5 * y;
        }

        // Circulo de abajo
        for (i = 0; i <= cantidadDeSectores; i++) {
          angulo = i * anguloDelSector;

          x = Math.cos(angulo);
          y = Math.sin(angulo);

          vertices[kv++] = radioAbajo * x;
          vertices[kv++] = radioAbajo * y;
          vertices[kv++] = -alto / 2;

          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 0;
          colores[kc++] = 1;

          // UVs
          uvs[ku++] = 0.5 + 0.5 * x;
          uvs[ku++] = 0.5 + 0.5 * y;
        }

        // UVs para la superficie lateral
        // Primero, para la parte lateral (de arriba a abajo)
        for (i = 0; i <= cantidadDeSectores; i++) {
          let t = i / cantidadDeSectores;
          // Arriba (v=1)
          uvs[ku++] = t; uvs[ku++] = 1;
          // Abajo (v=0)
          uvs[ku++] = t; uvs[ku++] = 0;
        }

        /* Se leen los indices */

        /**
         *  ki1 ------- ki1+1
         *     |     / | 
         *     |   /   |
         *     | /     |
         *  ki2 ------- ki2+1
         *  ki1,ki2,ki1+1, ki1+1,ki2,ki2+1 =>  2 triangulo
         */
        ki = 0
        let ki1 = 0;
        let ki2 = cantidadDeSectores + 1;
        for (j = 0; j < cantidadDeSectores; j++) {
          // ki2 => ki1+1 => ki1 
          indices[ki++] = ki2;
          indices[ki++] = ki1 + 1;
          indices[ki++] = ki1;

          // ki2 => ki2+1 => ki1+1 
          indices[ki++] = ki2;
          indices[ki++] = ki2 + 1;
          indices[ki++] = ki1 + 1;
          ki1++;
          ki2++;
        }

        if (arriba) {
          // centro
          let p, p1, nv;
          p = kv / 3;
          vertices[kv++] = 0;
          vertices[kv++] = 0;
          vertices[kv++] = alto / 2;

          colores[kc++] = 0;
          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 1;

          p1 = kv / 3;

          // Circulo de arriba
          for (i = 0; i <= cantidadDeSectores; i++) {
            nv = i * 3;
            vertices[kv++] = vertices[nv];
            vertices[kv++] = vertices[nv + 1];
            vertices[kv++] = vertices[nv + 2];

            colores[kc++] = 0;
            colores[kc++] = 1;
            colores[kc++] = 0;
            colores[kc++] = 1;
          }

          /**
           *             1
           *           / | 
           *         /   |
           *       /     |
           *    p ------- 0
           *    p,0,1  =>  3  indices
           */
          for (i = 0; i < cantidadDeSectores; i++) {
            indices[ki++] = p;       // p
            indices[ki++] = p1;      // 0
            indices[ki++] = p1 + 1;    // 1
            p1++;
          }
        }

        if (abajo) {
          // centro
          let p, p1, nv;
          p = kv / 3;
          vertices[kv++] = 0;
          vertices[kv++] = 0;
          vertices[kv++] = -alto / 2;

          colores[kc++] = 0;
          colores[kc++] = 1;
          colores[kc++] = 0;
          colores[kc++] = 1;

          p1 = kv / 3;
          j = cantidadDeSectores + 1;

          // Circulo de abajo
          for (i = 0; i <= cantidadDeSectores; i++) {
            nv = j * 3;
            vertices[kv++] = vertices[nv];
            vertices[kv++] = vertices[nv + 1];
            vertices[kv++] = vertices[nv + 2];

            colores[kc++] = 0;
            colores[kc++] = 1;
            colores[kc++] = 0;
            colores[kc++] = 1;
            j++;
          }

          /**
           *             1
           *           / | 
           *         /   |
           *       /     |
           *    p ------- 0
           *    p,0,2  =>  3  indices
           */
          for (i = 0; i < cantidadDeSectores; i++) {
            indices[ki++] = p;     // p
            indices[ki++] = p1;    // ki2
            indices[ki++] = p1 + 1;  // ki2 + 1
            p1++;
          }
        }

        console.log("Cant. triangulos: ", cantidadDeTriangulos);
        console.log("Cant. vertices: ", cantidadDeVertices);
        console.log("vertices: ", vertices.length / 3);
        for (let i = 0; i < vertices.length; i += 3) {
          console.log(i / 3 + " : " + vertices[i] + "  " + vertices[i + 1] + "  " + vertices[i + 2])
        }

        console.log("indices: ", indices.length);
        for (let i = 0; i < indices.length; i += 6) {
          console.log(i + " : " + indices[i] + "  " + indices[i + 1] + "  " + indices[i + 2] + "  " + indices[i + 3] + "  " + indices[i + 4] + "  " + indices[i + 5])
        }

        this.cilindroVAO = gl.createVertexArray();
        gl.bindVertexArray(this.cilindroVAO);

        var verticeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, verticeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        var uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

        var indiceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.cilindroVAO);
        gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class Esfera {
      constructor(gl, radio, segmentosH, segmentosV) {
        let cantidadDeVertices = (segmentosH + 1) * (segmentosV + 1);
        this.cantidadDeIndices = segmentosH * segmentosV * 6 * 2;
        let i, j, k, x, y, z, theta_, phi_, k1, k2, u, v, iCT;
        let vertices = new Float32Array(cantidadDeVertices * 3);
        let coord_textura = new Float32Array(cantidadDeVertices * 2);
        let colores = new Float32Array(cantidadDeVertices * 4); // <-- Agrega colores
        let indices = new Uint16Array(this.cantidadDeIndices);
        k = 0, iCT = 0;
        let theta = 2 * Math.PI / segmentosH;
        let phi = Math.PI / segmentosV;
        let kc = 0;
        for (i = 0; i <= segmentosV; i++) {
          phi_ = i * phi - Math.PI / 2;
          for (j = 0; j <= segmentosH; j++) {
            theta_ = j * theta;
            x = radio * Math.cos(theta_) * Math.cos(phi_);
            y = radio * Math.sin(theta_) * Math.cos(phi_);
            z = radio * Math.sin(phi_);
            vertices[k++] = x;
            vertices[k++] = y;
            vertices[k++] = z;
            u = j / segmentosH;

            v = i / segmentosV;
            coord_textura[iCT++] = u;
            coord_textura[iCT++] = v;

            // Colores del degradado
            const colorA = [0.0, 0.188, 0.286];   // #003049
            const colorB = [0.756, 0.070, 0.121]; // #c1121f

            // Interpolación lineal entre colorA y colorB según v
            let r = colorA[0] * (1 - v) + colorB[0] * v;
            let g = colorA[1] * (1 - v) + colorB[1] * v;
            let b = colorA[2] * (1 - v) + colorB[2] * v;

            colores[kc++] = r;
            colores[kc++] = g;
            colores[kc++] = b;
            colores[kc++] = 1.0;
          }
        }
        k = 0;
        for (i = 0; i < segmentosV; i++) {
          k1 = i * (segmentosH + 1);
          k2 = k1 + segmentosH + 1;
          for (j = 0; j < segmentosH; j++) {
            indices[k++] = k1 + j;
            indices[k++] = k2 + j + 1;
            indices[k++] = k2 + j;
            indices[k++] = k1 + j;
            indices[k++] = k1 + j + 1;
            indices[k++] = k2 + j + 1;
          }
        }
        this.esferaVAO = gl.createVertexArray();
        gl.bindVertexArray(this.esferaVAO);
        var codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(gl.ARRAY_BUFFER, colores, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
        var codigoCoordenadasDeTextura = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoCoordenadasDeTextura);
        gl.bufferData(gl.ARRAY_BUFFER, coord_textura, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);
        var codigoDeIndices = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, codigoDeIndices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      muestra(gl) {
        gl.bindVertexArray(this.esferaVAO);
        gl.drawElements(gl.TRIANGLES, this.cantidadDeIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    class ObjetoOBJ {
      constructor(gl, data) {
        this.numIndices = data.indices.length;
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);

        // Vértices (posición)
        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, data.positions, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

        // Colores (location = 1)
        const cbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
        gl.bufferData(gl.ARRAY_BUFFER, data.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        // UVs (location = 2)
        const uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, data.uvs, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(2);
        gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

        // Índices
        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.indices, gl.STATIC_DRAW);

        gl.bindVertexArray(null);
      }

      dibuja(gl) {
        gl.bindVertexArray(this.vao);
        gl.drawElements(gl.TRIANGLES, this.numIndices, gl.UNSIGNED_SHORT, 0);
        gl.bindVertexArray(null);
      }
    }

    /* Parser MTL (solo Kd) */
    function parseMTL(text) {
      const lines = text.split('\n');
      let materials = {};
      let current = null;

      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          current = line.split(/\s+/)[1];
          materials[current] = {
            Kd: [0.8, 0.8, 0.8, 1],
            Ka: [0.2, 0.2, 0.2, 1], // Ambient
            Ks: [0, 0, 0, 1],       // Specular
            Ns: 0,                  // Specular exponent
            d: 1,                   // Dissolve (transparency)
            illum: 1                // Illumination model
          };
        } else if (line.startsWith('Kd ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Kd = [r, g, b, 1];
        } else if (line.startsWith('Ka ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Ka = [r, g, b, 1];
        } else if (line.startsWith('Ks ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Ks = [r, g, b, 1];
        } else if (line.startsWith('Ns ') && current) {
          materials[current].Ns = parseFloat(line.split(/\s+/)[1]);
        } else if (line.startsWith('d ') && current) {
          materials[current].d = parseFloat(line.split(/\s+/)[1]);
        } else if (line.startsWith('illum ') && current) {
          materials[current].illum = parseInt(line.split(/\s+/)[1]);
        }
      }
      return materials; // <--- ¡Esto es lo que faltaba!
    }
    // Carga la textura
    function loadTexture(gl, image) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return tex;
    }

    function leeLaTextura(gl, ID_del_archivo, codigoDeTextura) {

      /* Se asigna un nombre (código) a la textura */
      gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura);

      /* true, invierte los píxeles en el orden de abajo hacia arriba que WebGL espera */
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      /* Obtiene la imagen */
      var imagen = document.getElementById(ID_del_archivo);

      /* Se lee la textura */
      /* |  tipo   |0=1 resol|RGB/RGBA |orden col|tip datos| buffer  | */
      /* |    1    |    2    |    3    |    4    |    5    |    6    | */
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imagen);

      /* Para que el patrón de textura se agrande y se acomode a una área grande */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      /* Para que el patrón de textura se reduzca y se acomode a una área pequeña */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

      /* Para repetir la textura tanto en s y t fuera del rango del 0 al 1
        * POR DEFECTO! */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

      /* Para limitar la textura tanto de s y t dentro del rango del 0 al 1 */
      //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      /* Se deja de asignar un nombre (código) a la textura */
      gl.bindTexture(gl.TEXTURE_2D, null);

    }

    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function mouseDown(event) {
      if (!arcballControl && event.button == 0) return false; // Deshabilita ArcBall si el checkbox está apagado
      if (!moveModel && event.button == 2) return false;      // Deshabilita mover si el checkbox está apagado

      // Coordenadas del mouse relativas al canvas
      const rect = canvas.getBoundingClientRect();
      const posx = event.clientX - rect.left;
      const posy = event.clientY - rect.top;

      if (event.button == 0 && arcballControl) { // botón izquierdo
        Matriz = MatrizRotacion.slice(); /* Copia */
        arcBall.primerPunto(posx, posy);
        boton_izq_presionado = true;
      } else if (event.button == 2 && moveModel) // botón derecho
        boton_der_presionado = true;

      return false;
    };

    function mouseUp(e) {
      boton_izq_presionado = false;
      boton_der_presionado = false;
    };

    function mouseMove(event) {
      if (!arcballControl && boton_izq_presionado) return;
      if (!moveModel && boton_der_presionado) return;

      const rect = canvas.getBoundingClientRect();
      const posx = event.clientX - rect.left;
      const posy = event.clientY - rect.top;

      if (boton_izq_presionado && arcballControl) {
        let q = arcBall.segundoPunto(posx, posy);
        Cuaternion.rota2(MatrizRotacion, q);
        multiplica(MatrizRotacion, MatrizRotacion, Matriz);
      } else if (boton_der_presionado && moveModel) {
        let txNorm = (posx * 10 / canvas.width) - 5;
        let tyNorm = (10 - posy * 10 / canvas.height) - 5;
        tx = txNorm;
        ty = tyNorm;
      }
    }



    /* Parser MTL (solo Kd) */
    function parseMTL(text) {
      const lines = text.split('\n');
      let materials = {};
      let current = null;

      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('newmtl ')) {
          current = line.split(/\s+/)[1];
          materials[current] = {
            Kd: [0.8, 0.8, 0.8, 1],
            Ka: [0.2, 0.2, 0.2, 1], // Ambient
            Ks: [0, 0, 0, 1],       // Specular
            Ns: 0,                  // Specular exponent
            d: 1,                   // Dissolve (transparency)
            illum: 1                // Illumination model
          };
        } else if (line.startsWith('Kd ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Kd = [r, g, b, 1];
        } else if (line.startsWith('Ka ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Ka = [r, g, b, 1];
        } else if (line.startsWith('Ks ') && current) {
          const [, r, g, b] = line.split(/\s+/).map(parseFloat);
          materials[current].Ks = [r, g, b, 1];
        } else if (line.startsWith('Ns ') && current) {
          materials[current].Ns = parseFloat(line.split(/\s+/)[1]);
        } else if (line.startsWith('d ') && current) {
          materials[current].d = parseFloat(line.split(/\s+/)[1]);
        } else if (line.startsWith('illum ') && current) {
          materials[current].illum = parseInt(line.split(/\s+/)[1]);
        }
      }
      return materials; // <--- ¡Esto es lo que faltaba!
    }
    // Carga la textura
    function loadTexture(gl, image) {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return tex;
    }

    function leeLaTextura(gl, ID_del_archivo, codigoDeTextura) {

      /* Se asigna un nombre (código) a la textura */
      gl.bindTexture(gl.TEXTURE_2D, codigoDeTextura);

      /* true, invierte los píxeles en el orden de abajo hacia arriba que WebGL espera */
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      /* Obtiene la imagen */
      var imagen = document.getElementById(ID_del_archivo);

      /* Se lee la textura */
      /* |  tipo   |0=1 resol|RGB/RGBA |orden col|tip datos| buffer  | */
      /* |    1    |    2    |    3    |    4    |    5    |    6    | */
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imagen);

      /* Para que el patrón de textura se agrande y se acomode a una área grande */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      /* Para que el patrón de textura se reduzca y se acomode a una área pequeña */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

      /* Para repetir la textura tanto en s y t fuera del rango del 0 al 1
        * POR DEFECTO! */
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

      /* Para limitar la textura tanto de s y t dentro del rango del 0 al 1 */
      //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      /* Se deja de asignar un nombre (código) a la textura */
      gl.bindTexture(gl.TEXTURE_2D, null);

    }

    /***************************************************************************/
    /* Eventos del Ratón                                                       */
    /***************************************************************************/

    function mouseDown(event) {
      if (!arcballControl && event.button == 0) return false; // Deshabilita ArcBall si el checkbox está apagado
      if (!moveModel && event.button == 2) return false;      // Deshabilita mover si el checkbox está apagado

      // Coordenadas del mouse relativas al canvas
      const rect = canvas.getBoundingClientRect();
      const posx = event.clientX - rect.left;
      const posy = event.clientY - rect.top;

      if (event.button == 0 && arcballControl) { // botón izquierdo
        Matriz = MatrizRotacion.slice(); /* Copia */
        arcBall.primerPunto(posx, posy);
        boton_izq_presionado = true;
      } else if (event.button == 2 && moveModel) // botón derecho
        boton_der_presionado = true;

      return false;
    };

    function mouseUp(e) {
      boton_izq_presionado = false;
      boton_der_presionado = false;
    };

    function mouseMove(event) {
      if (!arcballControl && boton_izq_presionado) return;
      if (!moveModel && boton_der_presionado) return;

      const rect = canvas.getBoundingClientRect();
      const posx = event.clientX - rect.left;
      const posy = event.clientY - rect.top;

      if (boton_izq_presionado && arcballControl) {
        let q = arcBall.segundoPunto(posx, posy);
        Cuaternion.rota2(MatrizRotacion, q);
        multiplica(MatrizRotacion, MatrizRotacion, Matriz);
      } else if (boton_der_presionado && moveModel) {
        let txNorm = (posx * 10 / canvas.width) - 5;
        let tyNorm = (10 - posy * 10 / canvas.height) - 5;
        tx = txNorm;
        ty = tyNorm;
      }
    }

    function zoom(event) {
      event.preventDefault();
      if (event.deltaY > 0) {
        sx = sx * 0.9;
        sy = sy * 0.9;
        sz = sz * 0.9;
      } else {
        sx = sx * 1.1;
        sy = sy * 1.1;
        sz = sz * 1.1;
      }
    };

    var animFrameId = null;

    function dibuja() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (autoRotateY) rotacionY(MatrizRotacion, 0.5);
      if (autoRotateX) rotacionX(MatrizRotacion, 0.5);

      identidad(MatrizModelo);
      traslacion(MatrizModelo, tx, ty, 0);
      escalacion(MatrizModelo, sx, sy, sz);
      multiplica(MatrizModelo, MatrizModelo, MatrizRotacion);
      gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

      // Obtén el tamaño del canvas para el aspecto
      const ancho = canvas.width;
      const alto = canvas.height;

      /* Define la Matriz de Proyección según la opción seleccionada */
      if (document.getElementById('proyeccionFrustum').checked) {
        //frustum(MatrizProyeccion, -1.15*ancho/alto, 1.15*ancho/alto, -1.15, 1.15, 2, 100);
        frustum(MatrizProyeccion, -0.7 * ancho / alto, 0.7 * ancho / alto, -0.7, 0.7, 4, 100);

      } else if (document.getElementById('proyeccionParalela').checked) {
        ortho(MatrizProyeccion, -10 * ancho / alto, 10 * ancho / alto, -10, 10, 2, 100);
      } else {
        // Si ninguna opción está seleccionada, no dibujar nada
        return;
      }
      gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

      gl.uniform1i(uUseTexture, usarTextura ? 1 : 0);
      if (usarTextura && textura) {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textura);
        gl.uniform1i(uSampler, 0);
      } else {
        gl.bindTexture(gl.TEXTURE_2D, null);
      }

      if (objetoActual === "cubo") {
        cubo.dibuja(gl);
      } else if (objetoActual === "cilindro") {
        cilindro.dibuja(gl);
      } else if (objetoActual === "cono") {
        cono.dibuja(gl);
      } else if (objetoActual === "esfera" && esfera) {
        esfera.muestra(gl);
      } else if (objetoActual === "obj" && objetoOBJ) {
        objetoOBJ.dibuja(gl);
      }

      if (showAxes) dibujaEjes(gl);
      if (document.getElementById("mostrarPiso") && document.getElementById("mostrarPiso").checked) {
        piso.dibuja(gl);
      }

      animFrameId = requestAnimationFrame(dibuja);
    }


    function reiniciaAnimacion() {
      if (animFrameId !== null) {
        cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }
      dibuja();
    }

    function dibujaEjes(gl) {
      // Ejes: X (rojo), Y (verde), Z (azul)
      const ejeVertices = new Float32Array([
        // X
        0, 0, 0, 3, 0, 0,
        // Y
        0, 0, 0, 0, 3, 0,
        // Z
        0, 0, 0, 0, 0, 3
      ]);
      const ejeColores = new Float32Array([
        1, 0, 0, 1, 1, 0, 0, 1, // X rojo
        0, 1, 0, 1, 0, 1, 0, 1, // Y verde
        0, 0, 1, 1, 0, 0, 1, 1  // Z azul
      ]);

      // Guarda el estado actual
      gl.useProgram(programaID);

      // Crea buffers temporales
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, ejeVertices, gl.STREAM_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      const cbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
      gl.bufferData(gl.ARRAY_BUFFER, ejeColores, gl.STREAM_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

      // Dibuja las líneas
      gl.drawArrays(gl.LINES, 0, 6);

      // Limpia
      gl.deleteBuffer(vbo);
      gl.deleteBuffer(cbo);
      gl.bindVertexArray(null);
      gl.deleteVertexArray(vao);
    }

    function reinicia() {
  // Restablece traslación y escala
  tx = 0; ty = 0;
  sx = sy = sz = 3;

  // Restablece la rotación
  identidad(MatrizRotacion);

  // Selecciona el cubo como objeto actual
  objetoActual = "cubo";
  document.getElementById("objeto3d").value = "cubo";

  // Restablece radios/material a color (no textura)
  document.querySelector('input[name="materialType"][value="color"]').checked = true;
  usarTextura = false;

  // Activa proyección paralela y desactiva frustum
  document.getElementById("proyeccionParalela").checked = true;
  document.getElementById("proyeccionFrustum").checked = false;

  // Opcional: deselecciona archivos y oculta opciones de OBJ
  document.getElementById("objFile").value = "";
  document.getElementById("textureFile").value = "";
  document.getElementById("objFileLabel").style.display = "none";
  document.getElementById("materialOptions").style.display = "block";

  // Redibuja la escena
  dibuja();
}

    function main() {
      canvas = document.getElementById("webglcanvas");
      resizeCanvas();
      gl = canvas.getContext("webgl2");
      if (!gl) {
        document.write("WebGL 2.0 no está disponible en tu navegador");
        return;
      }
      canvas.addEventListener("mousedown", mouseDown, false);
      canvas.addEventListener("mouseup", mouseUp, false);
      canvas.addEventListener("mouseout", mouseUp, false);
      canvas.addEventListener("mousemove", mouseMove, false);
      canvas.addEventListener("wheel", zoom, { passive: false });
      document.getElementById("reset").onclick = reinicia;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      compilaEnlazaLosShaders();
      uUseTexture = gl.getUniformLocation(programaID, "uUseTexture");
      uSampler = gl.getUniformLocation(programaID, "uSampler");

      cubo = new Cubo(gl);
      cilindro = new Cilindro(gl, 1, 2, 32, true, true);
      // cilindro = new Cilindro(gl, 1, 4, 24, true, true);
      cono = new Cono(gl, 1, 0, 2, 32, true, true);
      // cono = new Cono(gl, 1, 0, 4, 24, true, true);
      piso = new Piso(gl, 0.5, 0.5, 0.5); // Color gris, puedes cambiar los valores
      esfera = new Esfera(gl, 1, 48, 48);

      arcBall = new ArcBall(canvas.width, canvas.height);

      gl.useProgram(programaID);
      uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
      uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
      uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");
      identidad(MatrizVista);
      traslacion(MatrizVista, 0, 0, -60); // Aleja la cámara
      gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
      // NO vuelvas a poner identidad(MatrizVista) ni gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista) aquí
      identidad(MatrizRotacion);
      arcBall.ajusta(gl.canvas.width, gl.canvas.height);
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0.992, 0.941, 0.835, 1.0); // #fdf0d5 en RGB normalizado
      sx = sy = sz = 3; // Ajusta el valor a tu preferencia (por ejemplo, 5 veces más grande)
      dibuja();
    }

    // Escuchar los checkboxes y botones después de cargar la página
    window.onload = function () {
      main();
      document.getElementById("autoRotateX").addEventListener("change", function () {

        autoRotateX = this.checked;
      });
      document.getElementById("autoRotateY").addEventListener("change", function () {
        autoRotateY = this.checked;
      });
      document.getElementById("arcballControl").addEventListener("change", function () {
        arcballControl = this.checked;
      });
      document.getElementById("moveModel").addEventListener("change", function () {
        moveModel = this.checked;
      });
      document.getElementById("showAxes").addEventListener("change", function () {
        showAxes = this.checked;
      });
      document.getElementById("scaleUp").addEventListener("click", function () {
        sx *= 1.1; sy *= 1.1; sz *= 1.1;
      });
      document.getElementById("scaleDown").addEventListener("click", function () {
        sx *= 0.9; sy *= 0.9; sz *= 0.9;
      });
      document.getElementById("objeto3d").addEventListener("change", function () {
        objetoActual = this.value;
        // document.getElementById("textureFile").style.display = "block";
        document.getElementById("textureFileLabel").style.display = "inline-block";
        document.getElementById("materialOptions").style.display = "block";
        if (objetoActual === "obj") {
          // document.getElementById("objFile").style.display = "block";
          document.getElementById("objFileLabel").style.display = "inline-block";
          sx = sy = sz = 45; // O el valor que usas al cargar el OBJ con MTL
    ty = -3;           // O el valor que usas para centrar el OBJ
        } else {
          // document.getElementById("objFile").style.display = "none";
          document.getElementById("objFileLabel").style.display = "none";
          sx = sy = sz = 3;
          ty = 0;
        }
      });

      document.getElementById("objFile").addEventListener("change", function () {
        const label = document.getElementById("objFileLabel");
        if (this.files.length > 0) {
          label.textContent = "OBJ: " + this.files[0].name;
        } else {
          label.textContent = "OBJ";
        }
      });
      document.getElementById("textureFile").addEventListener("change", function () {
        const label = document.getElementById("textureFileLabel");
        if (this.files.length > 0) {
          label.textContent = "TEXTURA: " + this.files[0].name;
        } else {
          label.textContent = "TEXTURA";
        }
      });

      document.getElementById("objFile").addEventListener("change", async function (e) {
        const objFile = e.target.files[0];
        if (!objFile) return;

        // Leer OBJ para encontrar el archivo MTL
        const objText = await objFile.text();
        const mtlLine = objText.split('\n').find(line => line.startsWith('mtllib'));

        let mtlMaterials = {};
        if (mtlLine) {
          const mtlPath = mtlLine.split(/\s+/)[1];
          // Pide el archivo MTL aquí, dentro del evento de usuario
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.mtl';
          input.onchange = async (e2) => {
            const mtlFile = e2.target.files[0];
            if (mtlFile) {
              const mtlText = await mtlFile.text();
              mtlMaterials = parseMTL(mtlText);
            }
            // Parsear OBJ con los materiales
            const data = parseOBJ(objText, mtlMaterials);
            objetoOBJ = new ObjetoOBJ(gl, data);
            sx = sy = sz = 45; // Ajustar escala
            ty = -3;            // mueve el OBJ hacia abajo 
            dibuja();
          };
          input.click();
          return; // Salir, el resto se ejecuta en el onchange del input
        }

        // Si no hay MTL, parsea el OBJ directamente
        const data = parseOBJ(objText, mtlMaterials);
        objetoOBJ = new ObjetoOBJ(gl, data);
        sx = sy = sz = 20; // Ajustar escala
        dibuja();
      });

      document.getElementById("textureFile").addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (!file) return;
        const img = new window.Image();
        img.onload = function () {
          // Si ya existe una textura, elimínala
          if (codigoDeTextura) gl.deleteTexture(codigoDeTextura);
          codigoDeTextura = gl.createTexture();
          // Usar leeLaTextura para cargar la imagen como textura
          // Creamos un elemento <img> temporal en el DOM para usar su id
          img.id = "tempTextureImage";
          document.body.appendChild(img);
          leeLaTextura(gl, img.id, codigoDeTextura);
          document.body.removeChild(img);
          textura = codigoDeTextura;
          dibuja();
        };
        img.src = URL.createObjectURL(file);
      });

      // document.getElementById("mtlFile").addEventListener("change", function (e) {
      //   const file = e.target.files[0];
      //   if (!file) return;
      //   const reader = new FileReader();
      //   reader.onload = function (evt) {
      //     mtlMaterials = parseMTL(evt.target.result);
      //   };
      //   reader.readAsText(file);
      // });

      document.getElementsByName("materialType").forEach(radio => {
        radio.addEventListener("change", function () {
          usarTextura = this.value === "texture";
        });
      });

      document.getElementsByName("proyeccion").forEach(radio => {
        radio.addEventListener("change", dibuja);
      });

      document.getElementById("proyeccionParalela").addEventListener("change", function () {
        if (this.checked) document.getElementById("proyeccionFrustum").checked = false;
        reiniciaAnimacion();
      });
      document.getElementById("proyeccionFrustum").addEventListener("change", function () {
        if (this.checked) document.getElementById("proyeccionParalela").checked = false;
        reiniciaAnimacion();
      });
      document.getElementById("mostrarPiso").addEventListener("change", dibuja);
    };

    // Al iniciar, ajusta el tamaño del canvas al contenedor
    function resizeCanvas() {
      const canvas = document.getElementById("webglcanvas");
      const parent = canvas.parentElement;
      canvas.width = parent.clientWidth;
      canvas.height = parent.clientHeight;

      // Si ya tienes el contexto WebGL, ajusta el viewport y la proyección
      if (window.gl) {
        gl.viewport(0, 0, canvas.width, canvas.height);
        // Si usas ortho, puedes recalcular aquí si quieres que se adapte al aspecto
        // Por ejemplo:
        // let aspect = canvas.width / canvas.height;
        // ortho(MatrizProyeccion, -5*aspect, 5*aspect, -5, 5, -5, 5);
        // gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
      }

      if (window.arcBall) {
        arcBall.ajusta(canvas.width, canvas.height);
      }
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('DOMContentLoaded', resizeCanvas);

    function parseOBJ(text, mtlMaterials = {}) {
      const lines = text.split('\n');
      const positions = [];
      const tempUVs = [];
      const vertices = [];
      const indices = [];
      const uvs = [];
      const colors = [];
      let currentMaterial = null;
      let currentColor = [0.8, 0.8, 0.8, 1]; // Color por defecto
      const vertexMap = new Map();

      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('v ')) {
          const [, x, y, z] = line.split(/\s+/).map(parseFloat);
          positions.push([x, y, z]);
        } else if (line.startsWith('vt ')) {
          const [, u, v] = line.split(/\s+/).map(parseFloat);
          tempUVs.push([u, 1 - v]); // Invierte V para WebGL
        } else if (line.startsWith('mtllib ')) {
          // Ya manejamos esto en el evento de carga del MTL
        } else if (line.startsWith('usemtl ')) {
          currentMaterial = line.split(/\s+/)[1];
          if (currentMaterial && mtlMaterials[currentMaterial]) {
            currentColor = mtlMaterials[currentMaterial].Kd;
          } else {
            currentColor = [0.8, 0.8, 0.8, 1];
          }
        } else if (line.startsWith('f ')) {
          const verts = line.split(/\s+/).slice(1);
          let faceVerts = [];

          for (let v of verts) {
            const [vi, vti] = v.split('/').map(x => x ? parseInt(x, 10) - 1 : undefined);

            // Clave única por combinación de posición, UV y material
            const key = `${vi}_${vti}_${currentMaterial}`;

            if (!vertexMap.has(key)) {
              // Añadir nuevo vértice
              const pos = positions[vi];
              vertices.push(...pos);

              // UVs (con valores por defecto si no existen)
              if (vti !== undefined && tempUVs[vti]) {
                uvs.push(...tempUVs[vti]);
              } else {
                uvs.push(0, 0);
              }

              // Color basado en material actual
              colors.push(...currentColor);

              // Guardar índice
              vertexMap.set(key, vertices.length / 3 - 1);
            }

            faceVerts.push(vertexMap.get(key));
          }

          // Triangulación (asume caras convexas)
          for (let j = 1; j < faceVerts.length - 1; j++) {
            indices.push(faceVerts[0], faceVerts[j], faceVerts[j + 1]);
          }
        }
      }

      return {
        positions: new Float32Array(vertices),
        indices: new Uint16Array(indices),
        uvs: new Float32Array(uvs),
        colors: new Float32Array(colors)
      };
    }
  </script>
</body>

</html>